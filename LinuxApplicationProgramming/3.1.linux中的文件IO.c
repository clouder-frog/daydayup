
1. linux中的文件IO：在linux下如何操作文件、linux下一切皆是文件。
					什么是文件，文件在OS下如何被操作

2. 文件属性：文件相关的属性设置（跟属性设置相关的API函数）如何获取一个文件的属性，如何更改一个文件的属性

3. 获取系统信息（系统时间、随机数、proc中的文件）：如何在应用层通过OS的API获取系统的一些信息 

4. 进程（进程环境、进程控制、进程关系、守护进程、进程间通信）

5. 信号：如何用信号传递信息，如何捕获一个信号（给这个信号绑定一个执行函数），信号是GUI体系的基础（Qt有信号与槽的概念）

6. 高级IO：多路复用IO，异步。

7. 线程：多线程在多核CPU有天然的优势

8. 网络编程：很多网络服务器都是linux。linux网络功能很强大

3.1.4.open函数的flag详解1	
	本节讲解open函数的flag参数，主要是 /*读写权限flag*/ 和 /*判断文件是否存在*/
3.1.5.open函数的flag详解2
	本节接上节继续讲解open的flag，主要是创建文件标志、非阻塞标志和同步标志
3.1.6.文件读写的一些细节	
	本节讲解文件读写中一些细节，譬如errno的设置和perror函数、read/write函数中的count参数，最后简单探讨了io效率问题，引出了标准IO
3.1.7.linux系统如何管理文件	
	本节简单探讨linux系统对文件的管理方法，重点讲了inode、vnode等概念，文件在硬盘上静态存储和在内存中被打开时的映像方式等。
3.1.8.lseek详解	
	本节讲解lseek函数，该函数用来移动文件的操作指针。利用这一特性我们可以计算文件长度、生成空洞文件等。
3.1.9.多次打开同一文件与APPEND	
	本节探讨一个文件被多次打开时的情况，这种情况一般在文件共享中发生。重点讲了O_APPEND标志在其中的作用。
3.1.10.文件共享的实现方式
	本节正式提出文件共享的概念，并且分析了三种最长出现的文件共享的方式，以及他们的区别和联系
3.1.11.文件描述符的复制1
	本节引入文件描述符的复制，重点讲了dup函数，并且通过实例说明如何使用dup函数复制文件描述符。
3.1.12.文件描述符的复制2
	本节分析dup函数的缺陷，并且引入dup2函数来解决。
3.1.13.fcntl函数介绍
	本节介绍文件管理函数fcntl，该函数功能很强大，以后会经常用到，这里只是做初步的介绍和示例其基本用法。
3.1.14.标准IO库介绍
	本节引入标准IO库函数，并且使用常用标准IO库函数写一个简单的文件操作示例程序。
	
====================================================================================
====================================================================================
3.1.1.1、什么是应用编程
	典型的嵌入式产品的研发过程就是；
	第一步让linux系统在硬件上跑起来(系统移植工作)
	第二步基于linux系统来开发应用程序实现产品功能。

	基于linux去做应用编程，其实就是通过调用/*linux的系统API*/来实现
	如何/*使用linux系统提供的API（和C库函数）来实现一定的功能*/

3.1.1.4、什么是文件IO
	IO就是input/output，输入/输出。文件IO: //读写文件
		如何操作硬盘：
		(1)通过文件系统操作(通过文件名+路径来访问(访问是通过linux系统API))
		(2)如果没有文件系统就需要直接读写扇区(通过文件系统来管理底层的扇区)

3.1.2.1、什么是操作系统API（linux大概有200-300个API）
	(1)API是一些函数，这些函数是由linux系统提供支持的，由应用层程序来使用。
	(2)应用层程序通过调用API来/*调用操作系统*/中的各种功能。
	(3)//学习一个操作系统，其实就是学习使用这个操作系统的API

3.1.2.2、linux常用文件IO接口
	(1)open、close、write、read、lseek

3.1.2.3、文件操作的一般步骤
	(1)在linux中操作一个文件，一般是先open打开一个文件，得到一个文件描述符
        然后对文件进行读写操作(或其他操作), 最后close关闭文件

	(2)强调一点：对文件进行操作时，一定要先打开文件，打开成功后才能去操作
       最后读写完成之后一定要close关闭文件，否则可能会造成文件损坏

	(3)文件是存在/*块设备*/中(硬盘、nandflash、sd卡)的文件系统中，这种文件叫静态文件
       open打开一个文件时，linux内核做的操作包括：
		①内核在/*进程(当前正在运行的程序)*/中建立了一个打开文件的数据结构，记录下我们打开的这个文件
		②内核在内存中申请一段内存，并且将静态文件的内容从块设备中读取到内存中特定地址管理存放(叫动态文件)

	(4)当我们close关闭动态文件时，close内部内核将内存中的动态文件的内容去更新(同步)块设备中的静态文件。

	(6)为什么要这么设计？
		块设备本身有读写限制(NandFlash、SD等块设备的读写特征--频繁擦除写入会坏掉)
        本身对块设备进行操作非常不灵活(最小单位是sector, 常见size = 512 byte)
		内存可以按字节为单位来操作
		可以随机操作(内存RAM，random)

        hello world 首先通过OS的系统调用，加载到OS内核的open write实现
        (应用层将数据写入到内核write函数缓冲区就认为写入OK)
        此时数据还没有写到实际rom中, 还在OS内核的缓存buff中。 

3.1.2.4、/*重要概念*/ 文件描述符 //文件描述符是针对当前进程而言的
	(1)文件描述符其实实质是一个数字，这个数字在/*一个进程中*/表示一个特定的含义
		当我们open打开一个文件时：操作系统在内存中构建了一些数据结构来表示这个动态文件
		然后返回给应用程序一个数字作为文件描述符, //这个数字就和内存中维护这个动态文件的数据结构绑定
	(2)文件描述符：文件描述符就是用来区分/*一个程序*/打开的多个文件
	(3)文件描述符的/*作用域*/当前进程

3.1.3.1、打开文件与关闭文件
	(1)linux中的文件描述符fd的合法范围是0或者一个正整数，不可能是一个负数。
	(2)open返回的fd程序必须记录好，以后向这个文件的所有操作都要靠这个fd去对应这个文件，
		最后关闭文件时也需要fd去指定关闭这个文件。如果在我们关闭文件前fd丢掉，这个文件没法关闭了也没法读写了
		//重新fork一个进程来打开其他进程已经打开的文件？-- 2018-4-7 18:31:36

	man 1 linux shell命令
	man 2 API
	man 3 库函数

3.1.3.3、读取文件内容、向文件中写入
	(1)ssize_t read(int fd, void *buf, size_t count);
		返回值表示成功读取的字节数。
	(4)/*刚才先写入12字节，然后读出结果读出是0(但是读出成功了) -- 文件指针lseek的原因*/

3.1.4.open函数的flag详解1/*1.读写权限问题; 2.接续截断问题*/
    3.1.4.1、读写权限：O_RDONLY O_WRONLY O_RDWR 
        (1)linux中文件有读写权限，在open打开文件时也可以附带一定的权限说明
        (2)当我们附带了权限后，打开的文件就只能按照这种权限来操作
        //不填参数默认为 O_RDONLY -- 不会报错
        //打开文件时: 设置ram中读写权限, 打开不存在的文件时设置rom中读写权限

    3.1.4.2、打开存在并有内容的文件时：O_APPEND、O_TRUNC
        (2)O_TRUNC属性去打开文件时，如果//这个文件中本来是有内容的，则原来的内容会被丢弃
        (3)O_APPEND属性去打开文件时，如果这个文件中本来是有内容的，则新写入的内容会接续到原来内容的后面
        (4)默认不使用O_APPEND和O_TRUNC属性时. //在后面添加, 但是有长度限制, (一般O_APPEND比较好个人觉得)

3.1.4.3、exit、_exit、_Exit退出进程
    (1)当我们程序在前面步骤操作失败导致后面的操作都没有可能进行下去时，
        应该在前面的错误监测中结束整个程序，//不应该继续让程序运行下去了
    (2)我们如何退出程序？//一般情况下，进程 == 程序
        ①在main函数中用return，一般原则是程序正常终止return 0
        ②正式终止/*进程(程序)*/应该使用exit或者_exit或者_Exit之一

3.1.5.open函数的flag详解2
    3.1.5.1、打开不存在的文件时：O_CREAT、O_EXCL
        (5)结论：open中加入O_CREAT后，不管原来这个文件存在与否都能打开成功，
            如果原来这个文件不存在则创建一个空的新文件，
            如果原来这个文件存在则会重新创建这个文件，
            //原来的内容会被消除掉 --test 不符合 test 不符合 2018-4-11 11:11:19
        (7)flag：O_CREAT + O_EXCL
            没有文件时创建文件，如果文件存在open的 fd = -1
        (8)open函数在使用O_CREAT标志去创建文件时，可以使用第三个参数mode来指定要创建的文件的权限。
            mode使用4个数字来指定权限的，其中后面三个很重要，对应我们要创建的这个文件的权限标志。
            譬如一般创建一个可读可写不可执行的文件就用0666 // 注意在共享文件夹下文件读写权限异常的现象

    3.1.5.2、O_NONBLOCK
        (4)我们/*打开一个文件默认就是阻塞式*/, 如果你希望以非阻塞的方式打开文件，则flag中要加O_NONBLOCK标志。
        //只用于设备文件，而不用于普通文件。
        //设备文件：Linux中的一些硬件设备，这些硬件设备在Linux中是以文件的方式来访问(称之为设备文件)
        //设备文件有阻塞式和非阻塞式两种方式
        //在编写驱动时来实现阻塞式和非阻塞式

    3.1.5.3、O_SYNC
        (1)write阻塞等待底层完成写入才返回到应用层 //添加O_SYNC标志
        (2)/*不添加O_SYNC*/时write只是将内容//写入底层缓冲区即可返回，
            然后底层(操作系统中负责实现open、write这些操作的那些代码，也包含OS中读写硬盘等底层硬件的代码)
            在合适的时候会将buf中的内容一次性的同步到硬盘中。这种设计是为了提升硬件操作的性能和寿命

3.1.6.文件读写的一些细节
    3.1.6.1、errno和perror
        (1)errno(error number)linux系统中对各种常见错误编号, 当函数执行错误时，函数会返回一个特定的errno编号
        (2)/*errno是由OS来维护的一个全局变量*/
        (3)errno本身实质是一个int类型的数字，每个数字编号对应一种错误 // also 对应一个 Success
        (4)linux系统提供了一个函数perror(print error)/*读取errno*/并转化为错误信息字符串, 然后print
            //程序中不能直接访问errno
        //in return value description：open() and creat() return the new file descriptor \
            or -1 if an error occurred (in which case, errno is set appropriately)

    3.1.6.2、read和write的count/*后面继续讲*/
        (1)count和返回值的关系：
            count参数表示我们想要写或者读的字节数，返回值表示实际完成的要写或者读的字节数
        (2)count可以和阻塞非阻塞结合起来
        (3)需要读取或者写入大文件（譬如文件2MB），不会把count设置为 2*1024*1024
            而应该去把count设置为一个合适的数字(譬如2048、4096)//循环读取或者写入

    3.1.6.3、文件IO效率和标准IO
        (1)文件IO就指的是我们当前在讲的open、close、write、read等API函数构成的一套用来读写文件的体系，
            这套体系可以很好的完成文件读写，但是效率并不是最高的 // 考虑到传输成本
        (2)应用层C语言库函数提供了一些用来做文件读写的函数列表，叫标准IO。
            标准IO由一系列的C库函数构成(fopen、fclose、fwrite、fread)
            这些/*标准IO函数*/其实是由/*文件IO*/封装而来的 //底层实现仍是文件io
            标准IO加了封装之后在应用层添加一个缓冲机制，这样我们通过fwrite写入的内容不是直接进入/*内核中的buf*/
            而是在应用层标准IO库自己维护的buf中，
            然后标准IO库自己根据//操作系统单次write的最佳count, 选择好的时机, 完成write到内核中的buf
            /*内核中的buf*/再根据硬盘的特性来选择好的时机去最终写入硬盘中

3.1.7.linux系统如何管理文件
// -- 引言
    Linux中/*所有的设备都是以文件形式(设备文件)*/，驱动所形成的设备文件最终也是通过文件io的方法来操作
    这些/*对文件的操作最终是如何映射到对硬件的操作*/，也需要对文件管理策略有所了解
    扇区是硬件所能访问的最小的单元，所以一个扇区内部不能存放两个文件(所以硬盘喜欢大文件)(文件压缩的一个方面)
    每个扇区都有一个扇区号
  
    3.1.7.1、硬盘中的静态文件和inode（i节点）
        (1)文件存放在硬盘中，硬盘中存储的文件以一种/*固定的形式*/存放，称之为静态文件
        
        (2)硬盘中可以分为两大区域：硬盘内容管理表项，真正存储内容的区域
            操作系统访问硬盘时是先去读取硬盘内容管理表，从中找到要访问的那个文件的扇区级别的信息
            然后再用这个信息去查询真正存储内容的区域，最后得到我们要的文件
        
        (3)操作系统最初拿到的信息是文件名，最终得到的是文件内容
            第一步就是去查询硬盘内容管理表，这个管理表中/*以文件为单位*/记录了各个文件的各种信息
            每一个文件有一个信息列表(叫inode，i节点)其实质是一个结构体，这个结构体有很多元素
            每个元素记录了这个文件的一些信息，其中就包括文件名、文件在硬盘上对应的扇区号、块号・・・
        
        强调：硬盘管理的时候是以文件为单位
              每个文件一个inode，每个inode有一个数字编号，对应一个结构体，结构体中记录了各种信息

        快速格式化就是只删除了U盘中的硬盘内容管理表(inode)

    3.1.7.2、内存中被打开的文件和vnode（v节点）
        (1)一个程序的运行就是一个进程, 在程序中打开的文件就属于某个进程
            每个进程都有一个数据结构用来记录这个进程的所有信息/*进程信息表*/ -- //like tcb
            表中有一个指针会指向一个/*文件管理表*/, 文件管理表中记录了当前进程打开的所有文件及其相关信息
            文件管理表[数组]用来索引各个文件的index: 文件描述符fd
            最终找到的就是一个已经被打开的文件的管理结构体vnode -- //filePoint应该是vnode的成员变量
        
        (2)一个vnode中就记录了一个被打开的文件的各种信息
            通过文件的fd，就可以找到这个文件的vnode进而对这个文件进行各种操作

    3.1.7.3、文件与流的概念
        一个文件中N多的个字符被依次读出/写入时，这些字符就构成了一个字符流。
        流这个概念是动态的，不是静态的。
        编程中提到流这个概念，一般都是IO相关的。所以经常叫IO流。文件操作时就构成了一个IO流。

3.1.8.lseek详解
    3.1.8.1、lseek函数介绍
        (1)文件指针：对一个文件进行读写，需要先打开这个文件，所以我们读写的所有文件都是动态文件
            //动态文件在内存中的形态就是文件流的形式
        (3)在动态文件中, 通过文件指针来表征这个文件正在操作的位置 -- UI下的光标
            /*文件指针*/ 就是文件管理表[结构体数组]这个结构体里面的一个指针。
            /*文件指针*/ 其实是vnode中的一个元素, 这个指针表示当前我们正在操作文件流的哪个位置
            这个指针不能被直接访问, linux系统用/*lseek函数*/来访问这个文件指针
        (5)read和write函数都是从当前文件指针处开始操作

    3.1.8.2、用lseek计算文件长度
        //参数 offset 的含义取决于参数 whence：
            1. 如果 whence 是 SEEK_SET，文件偏移量 将被设置为 offset。
            2. 如果 whence 是 SEEK_CUR，文件偏移量 将被设置为 cfo 加上 offset，
               offset 可以为正也可以为负。
            3. 如果 whence 是 SEEK_END，文件偏移量 将被设置为文件长度加上 offset，
               offset 可以为正也可以为负。    

    3.1.8.3、用lseek构建空洞文件 
        (1)空洞文件就是这个文件中有一段是空的
        (2)普通文件中间是不会有空, write时文件指针是依次从前到后去移动
        (3)打开一个文件后, 用lseek往后跳过一段, 再write写入一段, 就会构成一个空洞文件。
        (4)空洞文件方法对/*多线程共同操作文件*/很有帮助
            有时候我们创建一个很大的文件，如果从头开始依次构建时间很长
            有一种思路就是将文件分为多段，然后多线程来操作每个线程负责其中一段的写入

// -- 文件加载到内存中是以流的形式存在, 文件指针的存在
// -- read write (close open) 可以隐式的改变文件指针 -- read是否可以隐式改变filePoint
// -- lseek可以显示的改变文件指针

// -- fileReadPoint && fileWritePoint 指针应该是同一个指针，读写都会对filePoint的位置进行改变 -- need test
// -- 文件重新关闭打开后，filePoint in init position
// -- O_APPEND只能在write操作关联filePoint, 在read情况下不能关联(同一个进程下打开不同文件的fd)
// -- 加上O_APPEND参数, 文件再执行写入操作的时候会自动跳到文件末尾. 一个进程重复打开应该操作内存中同一份拷贝 \
   -- 文件再内存中只有一份拷贝, 但是被多个file对象所指向, 每个fd又对应一个file对象
// -- 测试一个进程多次打开一个文件 和 多个进程多次打开同一个文件; 在内存中是不是都是同一份拷贝

// lesson9 && lesson10 repeat -- 2018-4-13
3.1.9.多次打开同一文件
    3.1.9.1、重复打开同一文件读取 // 普通文件可以被重复打开, 设备文件？
        (1) fd1和fd2分别读, 不是接续读写
            说明：使用open两次打开同一个文件时, fd1和fd2所对应的/*文件指针*/是不同的, 两个独立的指针
            -- 是两个独立的filePoint(), 还是两个独立的 vnode 2018-4-12
            // -- 两个fd对应两个file table(file table对象有一个成员:current file offset), 指向同一个vnode
            
            -- fd就是用来索引/*文件管理表*/中的数组成员-vnode
            -- 其中在一个进程中, fd不同则对应的vnode不同, vnode中的filePoint肯定也是不同
            
            文件指针是包含在动态文件的文件管理表中  // -- file manage table 指的是通过fd索引到的
            所以可以看出linux系统的进程中/*不同fd*/对应的是/*不同文件管理表*/

    3.1.9.2、重复打开同一文件写入 // 两个不同文件描述符对同一个文件进行操作的结果和现象
        (3)default写入方式: 分别写(两个fd对应的current file offset不能相互更新)

    3.1.9.3、加APPEND解决覆盖问题 // coverage
        (1)接续写而不是分别写: 在open时加O_APPEND标志

    3.1.9.4、APPEND的实现原理和其原子操作性说明  //linux文件共享的实现
        (1)O_APPEND为什么能够将分别写改为接续写? 关键的核心的东西是文件指针。
            分别写的内部原理就是2个fd拥有不同的文件指针，并且彼此只考虑自己的位移。
            但是O_APPEND标志可以让write和read函数内部多做一件事情， // -- read可以？测试
            就是移动自己的文件指针的同时也去把别人的文件指针同时移动。
            （也就是说即使加了O_APPEND，fd1和fd2还是各自拥有一个独立的文件指针，
            但是这两个文件指针关联起来了，一个动了会通知另一个跟着动）
        (2)O_APPEND对文件指针的影响, 对文件的读写是原子的 //-- man手册查看
        (3)原子操作的含义是：
            整个操作一旦开始是不会被打断的，必须直到操作结束其他代码才能得以调度运行，这就叫原子操作。
            每种操作系统中都有一些机制来实现原子操作，以保证那些需要原子操作的任务可以运行。

3.1.10.文件共享的实现方式
    3.1.10.1、什么是文件共享
        (1)文件共享就是/*同一个文件*/(同一个文件指的是同一个inode, 同一个pathname(static file))
            被多个独立的读写体(几乎可以理解为多个文件描述符)
            同时操作(一个打开尚未关闭, 同时另一个去操作)
        (2)文件共享的意义：通过文件共享来实现多线程同时操作同一个大文件，以减少文件读写时间，提升效率
            //也可以来实现进程间的通信, 效率不高

    3.1.10.2、文件共享的3种实现方式
        (1)文件共享的核心：获多个文件描述符指向同一个文件
        
        (2)常见的有3种文件共享的情况：
            同一个进程中多次使用open打开同一个文件
            不同进程中去分别使用open打开同一个文件(不同进程间fd没有相关性)
            linux系统提供了dup和dup2两个API来让进程复制文件描述符
        
        (3)分析文件共享时的核心关注点在于: 分别写/读还是接续写/读

    3.1.10.3、再论文件描述符
        (1)文件描述符的本质是一个数字, 这个数字本质上是/*进程表中文件描述符表*/的一个表项的index
            进程通过文件描述符作为index去索引查表得到文件表指针，再间接访问得到这个文件对应的文件表。
        (2)文件描述符这个数字是open系统调用内部由操作系统自动分配的
        (3)操作系统规定, fd从0开始依次增加, fd也是有最大限制, 文件描述符表其实就是一个数组，fd是index，文件表指针是value
        (4)当我们去open时，内核会从文件描述符表中挑选一个最小的未被使用的数字给我们返回
        (5)fd中0、1、2已经默认被系统占用了，因此用户进程得到的最小的fd就是3了
        (6)当我们运行一个程序得到一个进程时, 内部就默认已经打开了3个文件, 这三个文件对应的fd就是0、1、2。这三个文件分别叫stdin、stdout、stderr。也就是标准输入、标准输出、标准错误。
        (7)标准输入一般对应的是键盘（可以理解为：0这个fd对应的是键盘的设备文件），标准输出一般是LCD显示器（可以理解为：1对应LCD的设备文件）
        (8)printf函数其实就是默认输出到标准输出stdout上了。stdio中还有一个函数叫fpirntf，这个函数就可以指定输出到哪个文件描述符中。

        // 不同进程间 -> 文件描述符fd不同 -> 文件管理表(file table)不同 -> 文件指针(current file offset)不同
        // file table class {file status flags; current file offset; V-node pointer}

3.1.11.文件描述符的复制1
3.1.11.1、dup和dup2函数介绍

3.1.11.2、使用dup进行文件描述符复制
(1)dup系统调用对fd进行复制，会返回一个新的文件描述符（譬如原来的fd是3，返回的就是4）
(2)dup系统调用有一个特点，就是自己不能指定复制后得到的fd的数字是多少，而是由操作系统内部自动分配的，分配的原则遵守fd分配的原则。
(3)dup返回的fd和原来的oldfd都指向oldfd打开的那个动态文件，操作这两个fd实际操作的都是oldfd打开的那个文件。实际上构成了文件共享。
(4)dup返回的fd和原来的oldfd同时向一个文件写入时，结果是分别写还是接续写？

3.1.11.3、使用dup的缺陷分析
(1)dup并不能指定分配的新的文件描述符的数字，dup2系统调用修复了这个缺陷，所以平时项目中实际使用时根据具体情况来决定用dup还是dup2.
3.1.11.4、练习
(1)之前课程讲过0、1、2这三个fd被标准输入、输出、错误通道占用。而且我们可以关闭这三个
(2)我们可以close(1)关闭标准输出，关闭后我们printf输出到标准输出的内容就看不到了
(3)然后我们可以使用dup重新分配得到1这个fd，这时候就把oldfd打开的这个文件和我们1这个标准输出通道给绑定起来了。这就叫标准输出的重定位。
(4)可以看出，我们可以使用close和dup配合进行文件的重定位。


3.1.12.文件描述符的复制2
3.1.12.1、使用dup2进行文件描述符复制
(1)dup2和dup的作用是一样的，都是复制一个新的文件描述符。但是dup2允许用户指定新的文件描述符的数字。
(2)使用方法看man手册函数原型即可。

3.1.12.2、dup2共享文件交叉写入测试
(1)dup2复制的文件描述符，和原来的文件描述符虽然数字不一样，但是这连个指向同一个打开的文件
(2)交叉写入的时候，结果是接续写（实验证明的）。

3.1.12.3、命令行中重定位命令 >
(1)linux中的shell命令执行后，打印结果都是默认进入stdout的（本质上是因为这些命令譬如ls、pwd等都是调用printf进行打印的），所以我们可以在linux的终端shell中直接看到命令执行的结果。
(2)能否想办法把ls、pwd等命令的输出给重定位到一个文件中（譬如2.txt）去，实际上linux终端支持一个重定位的符号>很简单可以做到这点。
(3)这个>的实现原理，其实就是利用open+close+dup，open打开一个文件2.txt，然后close关闭stdout，然后dup将1和2.txt文件关联起来即可。


3.1.13.fcntl函数介绍
3.1.13.1、fcntl的原型和作用
(1)fcntl函数是一个多功能文件管理的工具箱，接收2个参数+1个变参。第一个参数是fd表示要操作哪个文件，第二个参数是cmd表示要进行哪个命令操作。变参是用来传递参数的，要配合cmd来使用。
(2)cmd的样子类似于F_XXX，不同的cmd具有不同的功能。学习时没必要去把所有的cmd的含义都弄清楚（也记不住），只需要弄明白一个作为案例，搞清楚它怎么看怎么用就行了，其他的是类似的。其他的当我们在使用中碰到了一个fcntl的不认识的cmd时再去查man手册即可。

3.1.13.2、fcntl的常用cmd
(1)F_DUPFD这个cmd的作用是复制文件描述符（作用类似于dup和dup2），这个命令的功能是从可用的fd数字列表中找一个比arg大或者和arg一样大的数字作为oldfd的一个复制的fd，和dup2有点像但是不同。dup2返回的就是我们指定的那个newfd否则就会出错，但是F_DUPFD命令返回的是>=arg的最小的那一个数字。

3.1.13.3、使用fcntl模拟dup2


3.1.14.标准IO库介绍
3.1.14.1、标准I O和文件IO有什么区别
(1)看起来使用时都是函数，但是：标准IO是C库函数，而文件IO是linux系统的API
(2)C语言库函数是由API封装而来的。库函数内部也是通过调用API来完成操作的，但是库函数因为多了一层封装，所以比API要更加好用一些。
(3)库函数比API还有一个优势就是：API在不同的操作系统之间是不能通用的，但是C库函数在不同操作系统中几乎是一样的。所以C库函数具有可移植性而API不具有可移植性。
(4)性能上和易用性上看，C库函数一般要好一些。譬如IO，文件IO是不带缓存的，而标准IO是带缓存的，因此标准IO比文件IO性能要更高。

3.1.14.2、常用标准IO函数介绍
(1)常见的标准IO库函数有：fopen、fclose、fwrite、fread、ffulsh、fseek

3.1.14.3、一个简单的标准IO读写文件实例


虚拟机上网：

nat方式：192.168.30.129
桥接方式：192.168.0.103

ln -s 软连接文件   l开头
ln 硬链接文件      -开头

apt-get install vim
apt-get remove vim

shell returned 127

一般在linux  /xxx 用来查找
在命令模式下。：行号  快速切换到某一行

cd -

cd ~ 
root用户下： /root
其他用户： /home/xxx


