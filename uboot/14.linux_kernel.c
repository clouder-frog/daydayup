
第二部分、章节介绍
2.14.1.内核和发行版的区别
	本节主要讲解linux内核和linux发行版的区别，并非不痛不痒的讲解，而是从几个方面的细节进行讲述。
2.14.2.内核和驱动的关联
	本节首先讲述操作系统学习的框架性思维，然后讲述了内核和驱动这两个概念的区别和关联。
2.14.3.内核和应用程序、根文件系统的关联
	本节讲述内核和应用程序的关联，内核和根文件系统的关联。
2.14.4.linux内核的模块化设计
	本节重点讲述linux内核的模块化设计理念及其优势，试图使大家对内核可配置有更深刻的认识。
2.14.5.选择合适版本的内核
	本节讲解linux内核的版本变迁，并且对各主要版本做介绍，最终讲了我们如何选择最适合自己的内核版本进行工作。
	

第三部分、随堂记录
2.14.1.内核和发行版的区别
2.14.1.1、到底什么是操作系统
(1)linux、windows、android、ucos就是操作系统
(2)操作系统本质上是一个程序，由很多个源文件构成，需要编译连接成操作系统程序（vmlinz、zImage）
(3)操作系统的主要作用就是管理计算机硬件，给应用程序提供一个运行环境。

2.14.1.2、操作系统核心功能：
(1)内存管理。如果没有操作系统，内存是需要程序自己来管理的。譬如在uboot中要使用内存的哪里是自己随便用的，没有注册也没有限制。这时候如果程序自己不小心把同一块内存重复用了就会出现程序逻辑错误。系统大了之后（内存多了）内存管理非常麻烦；有了操作系统之后，操作系统负责管控所有的内存，所有的应用程序需要使用内存时都要向操作系统去申请和注册，由操作系统的内存管理模块来分配内存给你使用，这样好处是可以保证内存使用不会冲突。
(2)进程调度。操作系统下支持多个应用程序同时运行（所以可以一边聊QQ一边看电影・・・），这是宏观上的并行。实际上在单核心CPU上微观上是不能并行的，宏观上的并行就是操作系统提供的分时复用机制。操作系统的进程调度模块负责在各个进程之间进行切换。
(3)硬件设备管理。没有操作系统时要控制任何硬件都要自己写代码，有了操作系统后操作系统本身会去控制各个硬件，应用程序就不用考虑硬件的具体细节了。操作系统的硬件设备管理模块就是驱动模块。
(4)文件系统。文件系统是管理存储设备的一种方式。存储设备是由很多个扇区组成的，每个扇区有512/1024/2048/4096字节，存储设备要以扇区为单位进行读写。如果没有文件系统，程序要自己去读写扇区，就得记得哪个文件在哪个扇区。有了文件系统之后我们人不用再关注扇区，人只用关注文件系统中的目录和文件名，而不用管这个文件在物理磁盘的哪个扇区。

2.14.1.3、操作系统扩展功能：
(1)协议栈
(2)有用的应用程序包。应用程序本身不属于操作系统内核的一部分，应用程序是给人用的，面向某种功能的。譬如ping程序用来测试网络是否联通，ifconfig程序用来配置网卡。

2.14.1.4、内核和发行版的区别
区别：内核是操作系统内核的简称，内核负责实现操作系统的核心功能（资源管理模块，譬如内存管理、调度系统・・・・・・），内核不包括应用程序。所以说只有内核人是没法用的，因为人做任何事情都是通过相应的应用程序来完成的。所以卖操作系统的人把内核和一些常用的应用程序打包在一起提供给普通用户，这就是操作系统的发行版（也就是普通意义上的操作系统）。
(1)内核只有一个。www.kernel.org
(2)发行版有很多。譬如ubuntu、redhat、suse、centos・・・・・・



2.14.2.内核和驱动的关联
2.14.2.1、学习linux的思路
(1)对庞大的整体要有个认识。学习路线就是先建立框架和整体，然后逐渐去学习各个细节部分，逐步细化。
(2)对各分层的作用要清楚。
(3)对层次间的关联和互相调用要理解。

2.14.2.2、驱动属于内核的一部分
(1)驱动就是内核中的硬件设备管理模块
(2)驱动工作在内核态。	// 是不受限制的
(3)驱动程序故障可能导致整个内核崩溃		// 有多少个设备就有多少个驱动
(4)驱动程序漏洞会使内核不安全

 // 驱动是内核的一部分, 写驱动就是在写操作系统内核
 // 内核代码量变得越来越大, 增长最快的部分就是驱动	// 近些年硬件更新快, 需要更新驱动支持
 // 内核调度模块变化小

2.14.3.内核和应用程序、根文件系统的关联
2.14.3.1、应用和内核的关系
(1)应用程序不属于内核，而是在内核之上的		// 现代操作系统一般都支持60000多个应用程序正常运行
(2)应用程序工作在用户态，是受限制的。
(3)应用程序故障不会导致内核崩溃
(4)应用程序通过内核定义的API接口来调用内核工作	// linux内核定义300多个api
(5)总结1：应用程序是最终目标
(6)总结2：内核就是为应用程序提供底层资源管理的服务员

2.14.3.2、内核和根文件系统
(1)根文件系统提供根目录
(2)进程1存放在根文件系统中			// 进程1是内核态与用户态的交界处(由内核态转到用户态), 进程1是第一个运行的应用程序  -- 因为没有根文件系统都无法切换到用户态
(3)内核启动最后会去/*装载*/根文件系统。
(4)总结：根文件系统为操作系统启动提供了很多必备的资源：根目录、进程1
	//进程1就在根目录下, 装载了(挂载了)根目录后, 在根目录下找到一个应用程序作为进程1去运行它, 于是乎就完成了启动(由内核态转到用户态, 整个操作系统启动完成)

 // 别的文件系统是挂载到根文件系统上(挂载到根文件系统的某一个节点上)
 // sd卡挂载在sdb(挂载点)上


2.14.4.linux内核的模块化设计
2.14.4.1、什么是模块化设计
(1)因为linux内核很庞大，代码量很大、东西很多，如果设计时完全设计成一体（各个文件、各个函数之间紧耦合），复杂度超出了人所能理解的范围。所以模块化设计也是一种必要。
(2)模块化设计就是内核中各个功能模块在代码上是彼此独立的，譬如说调度系统和内存管理系统之间并没有全局变量的互相引用，甚至函数互相调用也很少，就算有也是遵循一个接口规范的。模块化设计的目的就是实现功能模块的松耦合。

// 松耦合: 调度系统升级, 内存管理系统不升级仍能正常使用
// 紧耦合: 随意调用另一个文件的函数或全局变量

// 只要接口定义确定, 虽然调度系统升级, 但是只要保证接口函数不变, 调度系统和内存管理系统仍能对接
// 调度系统接口不变, 修改只体现为内部修改, 对外是不可见的

// linux内核模块设计程度非常高(可裁剪性高)

2.14.4.2、模块化设计的体现
(1)配置时可裁剪。linux内核在编译之前可以进行配置，配置时可以选择将组成内核的成千上万个模块每一个要或者不要。要了之后还有更多的一些细节的配置。
(2)模块化编译和安装。为了操作方便，逐渐从静态的升级变成了动态的升级（不需要重启系统，更不需要重新烧录系统）。这种动态的升级也是由模块化来支持的。
(3)源码中使用条件编译。这种在uboot中已经见过了

2.14.4.3、模块化设计的好处
(1)功能可裁剪、灵活性		// 瞬间获得稳定的协议栈
(2)可扩展性（动态安装卸载、新硬件支持）
(3)利于协作
 
2.14.4.4、模块化设计是一种普遍性的系统设计原则


2.14.5.选择合适版本的内核
2.14.5.1、linux内核版本变迁简史
(1)linux0.01。初版
(2)linux0.11。很多讲linux内核源代码解析的书都是以这个版本为原本来讲。《图解linux内核设计的艺术》
(3)linux2.4。比较接近现代的版本，很多经典的书都是以2.4版本内核为参照的，譬如《LDD3》。linux2.4的晚期内核在前几年还会经常碰到有用的。
(4)linux2.6早期。2.6的早期和2.4晚期内核挺像的。
(5)linux2.6晚期。2.6的晚期内核较早期内核有一些改变，尤其是驱动相关的部分和一些头文件的位置。2.6的晚期内核目前还算是比较主流。
(6)linux3.x 4.x
2.14.5.2、如何选择合适的内核版本
(1)并不是越新版本的内核越好
(2)选择SoC厂家移植版本会减少工作量
2.14.5.3、S5PV210适用的内核版本
(1)2.6.35.7+android2.3/QT4.8.3
(2)3.0.8+android4.0
2.14.5.4、本课程使用2.6.35.7版本内核讲解
































