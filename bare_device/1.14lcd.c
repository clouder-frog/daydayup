
1.14.1.1、什么是LCD
	(1)LCD(Liquid Crystal Display)
	(2)液晶材料: 可以在电信号的驱动下液晶分子进行旋转, 旋转时会影响透光性	// 背光 液晶分子旋转(透光) (彩色)滤光片
	(3)被动发光(LCD)和主动发光(LED, CRT)

1.14.1.2、其他主流显示设备	// 	CRT、等离子、LCD、LED、OLED	

1.14.1.4、LCD的发展史和种类	//	TN/STN/TFT

1.14.2.1、从电平角度来讲本质上都是TTL信号	//ttl电平(+5v:1, 0v:0)	--cmos电平
	(2)SoC的LCD控制器(LCDC)硬件接口是TTL电平, LCD这边硬件接口也是TTL电平	// 直接对接, 软排线
	(3)TTL电平传输距离有限	// 主机SoC(TTL) ->VGA-> LCD屏幕(TTL)

// 各种设备之间相连都需要接口, lcd接口数据量大, 接口复杂(数据量, 传输距离)

1.14.2.2、各种接口	// TTL、LVDS、EDP、MIPI -- 传输速率, 距离, 抗干扰, 适配性

1.14.2.3、RGB接口详解(参考数据手册P1207页时序图)
	(1)VD[23:0]: 数据线
	(2)HSYNC: 水平同步信号
	(3)VSYNC: 垂直同步信号	// 时序信号线, 为了让LCD能够正常显示给的控制信号
	(4)VCLK:  像素时钟		// LCD工作时需要主板控制器给LCD模组一个工作时钟信号，就是VCLK
	(5)VDEN:  数据有效标志	// 时序信号，和HSYNC、VSYNC结合使用
	(6)LEND:  行结束标志	// 时序信号，非必须，譬如X210接口就没有

1.14.3.1、像素	// pixel

1.14.3.2、扫描
	(1)扫描: 将颜色数值写入屏幕中所有像素	// 不是s型填充 -- lcd不需要扫描
	(3)显示器的扫描显示原理依赖于人眼的视觉暂留		// 扫描频率的概念就叫做刷新率

1.14.3.3、驱动器&控制器
	(1) lcd驱动器一般和lcd显示面板集成在一起	// Samsung做面板, 面板负责液晶分子旋转透光, 面板需要一定的模拟电信号来控制液晶分子

	(2)	/*驱动器*/由专门的IC厂商生产	// lcd驱动器由数字接口接收的控制信号, 给面板提供控制液晶分子的模拟电信号

	(3)	集成厂商买来面板和驱动器后集成在一起做成lcd屏幕	// aoc

	(4)	lcd控制器一般集成在SoC内部, 通过数字接口向lcd驱动器提供控制像素显示的数字信号
		//lcd controler的关键在于时序, 按照一定的时序和lcd驱动器通信
		//lcd controler受SoC控制, SoC会从内存中拿像素数据给lcd controler并最终传给lcd驱动器

	// warning: lcd driver

1.14.3.4、显示内存	// 显存 in soc ram
	(1) step1: cpu init lcd controler, /*lcd controler*/和/*显存*/构成映射	// -- 建立显示体系
	(2) step2: cpu将要显示的图像丢到显存中	// 硬件自动响应

	// cpu停止, 外设iis的mclk和bclk仍有时钟信号

1.14.5.2、LCD显示一帧图像的过程
	(1)一帧分为多行, 一行分为多个像素, 然后逐个像素去显示	//一帧图像就是多个像素组成的矩阵
	(2)lcd控制器和驱动器之间一次只能传一个像素点的显示数据, 所以一帧图像是/*串行*/依次被显示, 不是同一时间同时显示

1.14.5.3、为了向前兼容出现的六个时序参数
	HSPW 水平同步信号脉宽
	HBPD 水平同步信号前肩	// 一帧显示完, 移动到帧首
	HFPD 水平同步信号后肩	// 一行显示完, 移动到行首
	VSPW 垂直同步信号脉宽
	VBPD 垂直同步信号前肩
	VFPD 垂直同步信号后肩

	(1)一行的通信过程是这样的：LCD控制器先发送一个HSYNC高电平脉冲（脉冲宽度是HSPW），脉冲告诉驱动器下面的信息是一行信息。
		然后开始这一行信息，这一行信息包括3部分：HBPD+有效行信息+HFPD。
		其中前肩和后肩都属于时序信息（和LCD屏幕具体有关），有效行信息就是横向分辨率。
		所以你可以认为一行总共包含4部分：HSPW+HBPD+有效行信息+HFPD。
	(2)一帧图像其实就是一列，一列图像由多个行组成，每行都是上面讲的这个时序。
	(3)一帧图像的通信过程是这样的：整个帧图像信号分为4部分：VSPW+VBPD+帧有效信号+VFPD。
		VSPW是帧同步信号宽度，用来告诉驱动器一帧图像要开始了；VBPD和VFPD分别是垂直同步信号前后肩。
	(4)必须说明：这6个参数对于LCD显示器其实本来是没用的，这些信号其实是老式的CRT显示器才需要的，LCD本身不需要，
		但是出于历史兼容性要求，LCD选择了兼容CRT显示器的这些时序要求，所以理解LCD显示器时序和编程时，用CRT的方式来理解不会错。
	(5)要注意，这几个时序参数本身是LCD屏幕本身的参数，与LCD控制器无关。
		所以同一个主板如果接的屏幕不一样则时序参数设置也会不同。
		这些参数的来源一般是：第一，厂家会直接给出，一般以实例代码的形式给出；第二，来自于LCD的数据手册。
	第一种方式，查看九鼎的210裸机教程（x210v3裸机开发教程\src\template-framebuffer-font\source\hardware\s5pv210-fb.c的第774行）
			.h_fp			= 210,		// 160-210-354
			.h_bp			= 38,		// 46
			.h_sw			= 10,		// 1-40
			.v_fp			= 22,		// 7-22-147
			.v_fpe			= 1,
			.v_bp			= 18,		// 23
			.v_bpe			= 1,		
			.v_sw			= 7,		// 1-20
	第二种方式，查看LCD数据手册（X210光盘资料\A盘\DataSheet\AT070TN92.pdf）

	补充：
	(1) 注意这些数字的单位。H开头的三个单位都是DCLK(像素时钟),V开头的三个单位是TH	// 参数的单位和像素时钟有关
	(2) 这些时序参数如果没设置好会影响什么？屏幕会跑偏


1.14.7.1、颜色相关
	(1) 像素(pixel)
	(2) 像素间距(pitch)		// 影响屏幕的最佳观看距离
	(3) 像素深度(bits per pixel, bpp)	// RGB565(假彩色)、RGB888(真彩色)、ARGB(α表示透明度)
	(4)	颜色是主观存在(红绿色盲), 颜色的本质决定于光的波长
	(5) 光的波长是连续的, 颜色也是连续的	// 计算机中颜色是离散的
	(6)	三元色(三基色)RGB, 组合所有颜色

1.14.9.S5PV210的LCD控制器	// lcd厂商固定, lcd控制器相似
1.14.9.1、FIMD结构框图
(1)210的LCD控制器叫FIMD，FIMD是210内部和图像处理相关的一些部件，在摄像头等和图像处理有关的部分都可以有关联。
(2)FIMD在内部与AHB总线等相连接，在外部提供RGB接口、I80接口、YUV接口与外部相连接，我们实际使用的是RGB接口。

// RGB I80显示器使用, ITU摄像头使用

1.14.9.2、虚拟屏幕叠加（数据手册P1194）
(1)虚拟屏幕的意思是，我们平时看到的屏幕上显示出来的场景实际是很多个屏幕显示叠加在一起的效果/*新闻联播、各个电视台台标、下方飘动的字幕新闻*//*叠加后的图像发布后为一幅图像*/ 
(2)像S5PV210的LCD控制器中有5个虚拟屏幕Window0到Window4，虚拟屏幕不存在于真实而存在于内存中。
	（之前讲过，LCd显示时实际是显示的是对应的内存中的显存区域的数值）虚拟屏幕其实就是一个内存中的显存区域，
	有几个显存区域就有几个虚拟屏幕，但是这些虚拟屏幕都被映射到一个真实的显示屏上面，
	所以将来真实的现实效果实际是这几个虚拟屏幕的显示内容的叠加。
	（叠加时要注意上面一层会覆盖下面一层，所以要注意谁在前谁在后，设置寄存器时有这个选项）
(3)使用虚拟屏幕而不是整个LCD使用一个显存是有一定好处的：
	第一，可以保证不污染源图像，方便程序处理；
	第二，可以减少屏幕刷新/*对应写内存操作*/，提高显示效率，减少CPU工作量。

1.14.9.3、虚拟显示（数据手册P1206）
(1)如何实现在小分辨率的屏幕上（真实）显示大分辨率的图像
(2)细节上，我们需要屏幕上看到不同图像时，需要对显存区域进行刷新。即使我们只需要屏幕显示移动一点点，
	整个屏幕对应的显存空间也需要整个重新刷新，工作量和完全重新显示一幅图像是一样的。
	这个显然不好，这样CPU刷新屏幕的工作量太大了，效率很低。
(3)如何能够在显示一个大图片的不同区域时让CPU刷新屏幕工作量减少？有，方法就是虚拟显示。
	具体做法就是在内存中建立显示缓存的时候实际建立一个很大的区域，然后让LCD去对应其中的一部分区域作为有效的显示区域。
	将来要显示大图像时，直接将大图像全部一次性加载入显示缓存区，然后通过移动有效显示区域就可以显示大图像的不同区域了。
	// 如: 图像动画移动
	// 一般需要进行图像运算
	
1.14.9.4、主要寄存器简介

1.14.10.LCD编程实战1-LCD控制器初始化
参考代码lcd_init函数详解
(1)要想LCD工作，必须给LCD屏幕和显存之间建立一个映射（映射是在CPU初始化LCD控制器来完成的）
	本部分就是在完成这个过程（这也是LCD显示的2个阶段的第一阶段，第二阶段中我们只需要给显存中丢入相应的数据，LCD屏幕就会自动显示相应内容）


1.14.11.LCD编程实战2-显示像素&刷背景
(1)显示像素
(2)刷背景色

	// static
	// static incline

1.14.12.LCD编程实战3-横线竖线斜线&画圆
(1)画横线&竖线
(2)斜线


1.14.13.LCD编程实战4-写英文中文字符


1.14.14.LCD编程实战5-画图
1.14.14.1、图片显示分析
(1)图像是彩色的，而之前的文字、图形都是单色的。之前的图形文字绘制函数都有个color参数，就是传给显存告诉它这个像素的显示颜色。
(2)一副分辨率是800×480，BPP是24的图片，实际上就是800×480×3字节的数据。将来写代码将图片显示到LCD中时，图片将会以 unsigned char pic_data[800×480×3]的形式出现。
1.14.14.2、Image2LCD使用简介
(1)如何由一副图片得到它对应的数据的数组？要用取模工具，如Image2LCD。
1.14.14.3、画图函数的编写


1.14.15.LCD编程实战6-画图测试及调试
1.14.15.1、画图函数的显示效果测试
1.14.15.2、RGB的像素顺序调整
(1)图片中红色的变成了蓝色、蓝色的变成了红色，这就说明RGB顺序反了。
(2)解决方案一：重新使用Image2LCD来取模，取模时RGB顺序对调。
(3)解决方案二：不重新取模，改代码，在color形成的时候调换顺序。

1.14.15.3、小分辨率图片显示
(1)本质上大小分辨率的图像显示都是一样的，都是：都是在图像的每个像素点对应的显存中填入相应的颜色值即可。


1.14.16.未完成事项展望
1.14.16.1、RGB565和RGB888
(1)单片机等性能和资源有限的平台会用RGB565，嵌入式平台习惯用RGB888.
(2)有时候手头只有RGB888的颜色值，但是显示部分却只接受RGB565的（有时候反过来），这时候就需要在2种颜色之间做转换。

1.14.16.2、不同分辨率、不同起点坐标下的显示
(1)屏幕分辨率和图像分辨率不同时的显示。我们现在写的代码都是没有考虑的。
(2)图像起点坐标（左上角坐标）不一定在屏幕左上角，也可能在屏幕的任何其他区域，这种情况下画图的函数要做处理来支持。
(3)分辨率不同而且起始坐标不同下，这两个问题组合起来也对画图函数提出了更高要求。

1.14.16.3、bmp图片格式解析及显示
(1)我们当前的图像数据是用Image2LCD工具转过来的。实践中是不可能手工用工具来转的（你想一下Image2LCD也是一个软件，既然它能转，我们也应该可以用软件来转）
(2)bmp格式的图片本身遵照一定的格式来存储的，我们只需按照bmp的解析格式来读取文件就可得到这幅图片的图像数据的二进制，直接拿去显示。（这就是图片文件的本质）

1.14.16.4、jgp、png、gif等压缩图片的解码和显示
(1)对于以上压缩格式的图片是不能直接解析的，必须用相应的库来解压缩图片之后才能拿来显示。
(2)不同的格式的图片其压缩算法不同，解压缩算法自然也不同。开源社区中每种压缩格式都有个对应的库，库里提供了这种格式的压缩和解压缩函数，我们只需要移植这个库并且调用它来压缩或解压缩即可。

1.14.16.5、图片缩小和放大显示
(1)图片数据源本来是400×200的，但是显示时我希望显示成100×50的，这时候就要显示函数后台对源图像进行先缩小，然后再显示。这时候就需要一个缩小算法。（譬如最简单的算法就是抽点采样）
(2)图片数据源是100×50的，但是显示时希望全屏显示（800×480），这时候就需要对源图像进行放大然后再显示（当然了显示出来图像清晰度肯定比较低），这时候就需要一种放大算法（譬如插点方式）

1.14.16.6、显示动画
(1)动态刷屏形成动画
(2)立体3D图像显示（伪3D）





















