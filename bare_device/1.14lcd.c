
1.14.1.1、什么是LCD？
	(1)LCD(Liquid Crystal Display)
	(2)液晶材料: 可以在电信号的驱动下液晶分子进行旋转, 旋转时会影响透光性	// 背光 液晶分子旋转(透光) (彩色)滤光片
	(3)被动发光(LCD)和主动发光(LED, CRT)
	
1.14.1.2、其他主流显示设备	// 	CRT、等离子、LCD、LED、OLED	

1.14.1.4、LCD的发展史和种类	//	TN/STN/TFT

1.14.2.1、从电平角度来讲本质上都是TTL信号	//ttl电平(+5v:1, 0v:0)	--cmos电平
	(2)SoC的LCD控制器(LCDC)硬件接口是TTL电平, LCD这边硬件接口也是TTL电平	// 直接对接, 软排线
	(3)TTL电平传输距离有限	// 主机SoC(TTL) ->VGA-> LCD屏幕(TTL)

// 各种设备之间相连都需要接口, lcd接口数据量大, 接口复杂(数据量, 传输距离)


1.14.2.2、各种接口	// TTL、LVDS、EDP、MIPI -- 传输速率, 距离, 抗干扰, 适配性

1.14.2.3、RGB接口详解(参考数据手册P1207页时序图)
	(1)VD[23:0]: 数据线
	(2)HSYNC: 水平同步信号
	(3)VSYNC: 垂直同步信号	// 时序信号线, 为了让LCD能够正常显示给的控制信号
	(4)VCLK:  像素时钟		// LCD工作时需要主板控制器给LCD模组一个工作时钟信号，就是VCLK
	(5)VDEN:  数据有效标志	// 时序信号，和HSYNC、VSYNC结合使用
	(6)LEND:  行结束标志	// 时序信号，非必须，譬如X210接口就没有

1.14.3.1、像素	// pixel

1.14.3.2、扫描	// 不是s型填充
	(1)扫描: 将颜色数值写入屏幕中所有像素	// 不是S型填充 -- LCD不需要扫描
	(3)显示器的扫描显示原理依赖于人眼的视觉暂留。只要显示器扫描频率大于人眼的发现频率，人眼看到的图像就是恒定的。如果扫描频率偏小人眼就会看到闪动。（扫描频率的概念就叫做刷新率）

1.14.3.3、驱动器&控制器
	(1)LCD驱动器一般和LCD显示面板集成在一起（本来是分开的，做面板的是只做面板的，譬如说三星、LG、台湾的友达、奇美都是做面板的；
		驱动器也由专门的IC厂商生产；
		集成厂商买来面板和驱动器后集成在一起做成LCD屏幕），
		面板只负责里面的液晶分子旋转透光，面板需要一定的模拟电信号来控制液晶分子；
		LCD驱动器芯片负责给面板提供控制液晶分子的模拟电信号，驱动器的控制信号（数字信号）来自于自己的数字接口，这个接口就是LCD屏幕的外部接口（第二节中讲到的接口）
	(2)LCD控制器一般集成在SoC内部，他负责通过数字接口向远端的LCD驱动器提供控制像素显示的数字信号。LCD控制器的关键在于时序，它必须按照一定的时序和LCD驱动器通信；LCD控制器受SoC控制，SoC会从内存中拿像素数据给LCD控制器并最终传给LCD驱动器。

1.14.3.4、显示内存(简称：显存)
	(1)SoC在内存中挑选一段内存（一般来说是程序员随便挑选的，但是挑选的时候必须符合一定规矩），然后通过配置将LCD控制器和这一段内存（以后称为显存）连接起来构成一个映射关系。一旦这个关系建立之后，LCD控制器就会自动从显存中读取像素数据传输给LCD驱动器。这个显示的过程不需要CPU的参与。
	(2)显示体系建立起来后，CPU就不用再管LCD控制器、驱动器、面板这些东西了；以后CPU就只关心显存了，因为我只要把要显示的图像的像素数据丢到显存中，硬件就会自动响应（屏幕上就能自动看到显示的图像了）。

	总结：LCD显示是分为2个阶段的：第一个阶段就是建立显示体系的过程，目的就是CPU初始化LCD控制器使其和显存联系起来构成映射；第二个阶段就是映射建立之后，此阶段主要任务是将要显示的图像丢到显存中去。

1.14.5.LCD的六个主要时序参数
1.14.5.1、LCD显示单位：帧（frame）
(1)显示器上一整个画面的内容成为一个帧(frame)，整个显示器工作时是一帧一帧的在显示。
(2)电影实际就是以每秒种24帧的速度在播放图片。
(3)帧内数据：一帧分为多行，一行分为多像素，因此一帧图像其实就是多个像素组成的矩阵。
(4)帧外数据：整个视频由很多个帧构成，最终播放视频时逐个播放各个图像帧即可。

1.14.5.2、LCD显示一帧图像的过程
(1)首先把帧分为行，然后再把行分为像素，然后逐个像素去显示。（显示像素：其实就是LCD驱动器按照接收到的LCD控制器给的显示数据，驱动一个像素的液晶分子旋转，让这个像素显示出相应的颜色值的过程）
(2)关键点：LCD控制器和驱动器之间一次只能传一个像素点的显示数据。所以一帧图像在屏幕上其实是串行的依次被显示上去的，不是同一时间显示出来的。

1.14.5.3、为了向前兼容出现的六个时序参数
HSPW 水平同步信号脉宽
HBPD 水平同步信号前肩
HFPD 水平同步信号后肩
VSPW 垂直同步信号脉宽
VBPD 垂直同步信号前肩
VFPD 垂直同步信号后肩

(1)一行的通信过程是这样的：LCD控制器先发送一个HSYNC高电平脉冲（脉冲宽度是HSPW），脉冲告诉驱动器下面的信息是一行信息。然后开始这一行信息，这一行信息包括3部分：HBPD+有效行信息+HFPD。其中前肩和后肩都属于时序信息（和LCD屏幕具体有关），有效行信息就是横向分辨率。所以你可以认为一行总共包含4部分：HSPW+HBPD+有效行信息+HFPD。
(2)一帧图像其实就是一列，一列图像由多个行组成，每行都是上面讲的这个时序。
(3)一帧图像的通信过程是这样的：整个帧图像信号分为4部分：VSPW+VBPD+帧有效信号+VFPD。VSPW是帧同步信号宽度，用来告诉驱动器一帧图像要开始了；VBPD和VFPD分别是垂直同步信号前后肩。
(4)必须说明：这6个参数对于LCD显示器其实本来是没用的，这些信号其实是老式的CRT显示器才需要的，LCD本身不需要，但是出于历史兼容性要求，LCD选择了兼容CRT显示器的这些时序要求，所以理解LCD显示器时序和编程时，用CRT的方式来理解不会错。
(5)要注意，这几个时序参数本身是LCD屏幕本身的参数，与LCD控制器无关。所以同一个主板如果接的屏幕不一样则时序参数设置也会不同。这些参数的来源一般是：第一，厂家会直接给出，一般以实例代码的形式给出；第二，来自于LCD的数据手册。
第一种方式，查看九鼎的210裸机教程（x210v3裸机开发教程\src\template-framebuffer-font\source\hardware\s5pv210-fb.c的第774行）
		.h_fp			= 210,		// 160-210-354
		.h_bp			= 38,		// 46
		.h_sw			= 10,		// 1-40
		.v_fp			= 22,		// 7-22-147
		.v_fpe			= 1,
		.v_bp			= 18,		// 23
		.v_bpe			= 1,		
		.v_sw			= 7,		// 1-20
第二种方式，查看LCD数据手册（X210光盘资料\A盘\DataSheet\AT070TN92.pdf）

补充：
1、注意这些数字的单位。H开头的三个单位都是DCLK(像素时钟),V开头的三个单位是TH。这样设置的好处是我们改变了像素时钟的设置时，不用改变这里的时序参数。
2、这些时序参数如果没设置好会影响什么？屏幕会跑偏。


1.14.7.LCD显示的主要相关概念
1.14.7.1、像素（pixel）
(1)整个图像是由一个个的像素组成的，像素就是一个显示点。
1.14.7.2、像素间距（pitch）
(1)pitch是连续2个像素的像素中心的距离。一般的像素是方形的，所以横向pitch和纵向的pitch一样的。但是也有不一样的。
(2)像素间距会影响屏幕的最佳观看距离。像素间距大的适合远距离看，像素间距小的适合近距离看。

1.14.7.3、分辨率（resolution）
(1)整个屏幕的横向和纵向的像素个数就叫分辨率，譬如X210开发板用的屏幕是800×480.
(2)屏幕尺寸和分辨率无关的，像开发板的屏幕尺寸是7寸的（纯屏幕对角线尺寸是7英寸）。
(3)屏幕尺寸和分辨率和像素间距三者之间有关联。

1.14.7.4、清晰度
(1)清晰度是一个主观概念，是人眼对显示效果的一个主观判断。说白了就是人看起来感觉清晰不清晰。
(2)客观来讲，清晰度由分辨率和像素间距共同决定。一般的，屏幕尺寸固定时分辨率越高越清晰，分辨率越低就越不清晰；分辨率固定下，屏幕尺寸越小越清晰，越大越不清晰。
(3)清晰度还由其他很多因素共同决定。

1.14.7.5、像素深度（bits per pixel，简称bpp）
(1)一个像素在计算机中由多少个字节数据来描述。
(2)计算机中用二进制位来表示一个像素的数据，用来表示一个像素的数据位越多，则这个像素的颜色值更加丰富、分的更细，颜色深度就更深。
(3)一般来说像素深度有这么几种：1位、8位、16位、24位、32位。


1.14.8.颜色在计算机中的表示
1.14.8.1、颜色的本质
(1)颜色是主观存在，颜色其实是自然光在人的眼睛中和大脑中产生的一种映像。
(2)颜色的本质决定于光的波长。
1.14.8.2、自然光的颜色是连续的
(1)光的波长是连续的，导致颜色也是连续的。理论上，只要你的眼睛分辨能力足够好，可以在自然界中发现无数中颜色。

1.14.8.3、计算机中的颜色是离散的
(1)计算机中不可能存储无数种颜色，所以必须将颜色有限化，所以就用有限种颜色来代表自然界中的无限种颜色。这个理论非常类似于之前学过的AD转换。
(2)这种离散化表达颜色的缺点是不够真实，漏掉了很多种颜色。因此计算机中所能表达的颜色没有自然界中丰富（计算机屏幕上显示的图像和真实图像有差别）
(3)计算机所能表达的颜色种类个数，这个参数叫：像素深度bpp。

1.14.8.4、常见像素深度：1位、8位、16位、24位、32位
1位：用1个二进制位来表示颜色，这种就叫单色显示。示例就是小饭店、理发店门口的LED屏。
8位：用8个二进制位来表示颜色，此时能表示256种颜色。这种叫灰度显示。这时候是黑白的，没有彩色，我们把纯白到纯黑分别对应255到0，中间的数值对应不同的灰。示例就是以前的黑白电视机。
16位：用16个二进制位表示颜色，此时能表示65536种颜色。这时候就可以彩色显示了，一般是RGB565的颜色分布（用5位二进制表示红色、用6位二进制表示绿色、用5位二进制表示蓝色）。这种红绿蓝都有的颜色表示法就是一种模拟自然界中所有颜色的表示方式。但是因为RGB的颜色表达本身二进制位数不够多（导致红绿蓝三种颜色本身分的都不够细致），所以这样显示的彩色失真比较重，人眼能明显看到显示的不真实。
24位：用24个二进制位来表示颜色，此时能表示16777216种颜色。这种表示方式和16位色原理是一样的，只是RGB三种颜色各自的精度都更高了（RGB各8位），叫RGB888。此时颜色比RGB565更加真实细腻，虽然说比自然界无数种颜色还是少了很多，不过由于人眼的不理想性所以人眼几乎不能区分1677万种颜色和无数种颜色的差别了。于是乎就把这种RGB888的表示方法叫做真彩色。（RGB565就是假彩色）
32位：总共用32位二进制来表示颜色，其中24位表示红绿蓝三元色（还是RGB888分布），剩下8位表示透明度。这种显色方式就叫ARGB（A是阿尔法，表示透明度），现在PC机中一般都用ARGB表示颜色。

补充：颜色的组成，三元色（三基色）是RGB，也就是说所有的颜色都可以由红绿蓝三种颜色组成。


1.14.9.S5PV210的LCD控制器	// lcd厂商固定, lcd控制器相似
1.14.9.1、FIMD结构框图
(1)210的LCD控制器叫FIMD，FIMD是210内部和图像处理相关的一些部件，在摄像头等和图像处理有关的部分都可以有关联。
(2)FIMD在内部与AHB总线等相连接，在外部提供RGB接口、I80接口、YUV接口与外部相连接，我们实际使用的是RGB接口。

1.14.9.2、虚拟屏幕叠加（数据手册P1194）
(1)虚拟屏幕的意思是，我们平时看到的屏幕上显示出来的场景实际是很多个屏幕显示叠加在一起的效果（譬如新闻图像、电视台台标、下方飘动的字幕新闻）
(2)像S5PV210的LCD控制器中有5个虚拟屏幕Window0到Window4，虚拟屏幕不存在于真实而存在于内存中。（之前讲过，LCd显示时实际是显示的是对应的内存中的显存区域的数值）虚拟屏幕其实就是一个内存中的显存区域，有几个显存区域就有几个虚拟屏幕，但是这些虚拟屏幕都被映射到一个真实的显示屏上面，所以将来真实的现实效果实际是这几个虚拟屏幕的显示内容的叠加。（叠加时要注意上面一层会覆盖下面一层，所以要注意谁在前谁在后，设置寄存器时有这个选项）
(3)使用虚拟屏幕而不是整个LCD使用一个显存是有一定好处的：第一，可以保证不污染源图像，方便程序处理；第二，可以减少屏幕刷新，提高显示效率，减少CPU工作量。

1.14.9.3、虚拟显示（数据手册P1206）
(1)如何实现在小分辨率的屏幕上（真实）显示大分辨率的图像
(2)细节上，我们需要屏幕上看到不同图像时，需要对显存区域进行刷新。即使我们只需要屏幕显示移动一点点，整个屏幕对应的显存空间也需要整个重新刷新，工作量和完全重新显示一幅图像是一样的。这个显然不好，这样CPU刷新屏幕的工作量太大了，效率很低。
(3)如何能够在显示一个大图片的不同区域时让CPU刷新屏幕工作量减少？有，方法就是虚拟显示。具体做法就是在内存中建立显示缓存的时候实际建立一个很大的区域，然后让LCD去对应其中的一部分区域作为有效的显示区域。将来要显示大图像时，直接将大图像全部一次性加载入显示缓存区，然后通过移动有效显示区域就可以显示大图像的不同区域了。

1.14.9.4、主要寄存器简介


1.14.10.LCD编程实战1-LCD控制器初始化
参考代码lcd_init函数详解
(1)要想LCD工作，必须给LCD屏幕和显存之间建立一个映射（映射是在CPU初始化LCD控制器来完成的）。本部分就是在完成这个过程（这也是LCD显示的2个阶段的第一阶段，第二阶段中我们只需要给显存中丢入相应的数据，LCD屏幕就会自动显示相应内容）。


1.14.11.LCD编程实战2-显示像素&刷背景
(1)显示像素
(2)刷背景色

1.14.12.LCD编程实战3-横线竖线斜线&画圆
(1)画横线&竖线
(2)斜线


1.14.13.LCD编程实战4-写英文中文字符


1.14.14.LCD编程实战5-画图
1.14.14.1、图片显示分析
(1)图像是彩色的，而之前的文字、图形都是单色的。之前的图形文字绘制函数都有个color参数，就是传给显存告诉它这个像素的显示颜色。
(2)一副分辨率是800×480，BPP是24的图片，实际上就是800×480×3字节的数据。将来写代码将图片显示到LCD中时，图片将会以 unsigned char pic_data[800×480×3]的形式出现。
1.14.14.2、Image2LCD使用简介
(1)如何由一副图片得到它对应的数据的数组？要用取模工具，如Image2LCD。
1.14.14.3、画图函数的编写


1.14.15.LCD编程实战6-画图测试及调试
1.14.15.1、画图函数的显示效果测试
1.14.15.2、RGB的像素顺序调整
(1)图片中红色的变成了蓝色、蓝色的变成了红色，这就说明RGB顺序反了。
(2)解决方案一：重新使用Image2LCD来取模，取模时RGB顺序对调。
(3)解决方案二：不重新取模，改代码，在color形成的时候调换顺序。

1.14.15.3、小分辨率图片显示
(1)本质上大小分辨率的图像显示都是一样的，都是：都是在图像的每个像素点对应的显存中填入相应的颜色值即可。


1.14.16.未完成事项展望
1.14.16.1、RGB565和RGB888
(1)单片机等性能和资源有限的平台会用RGB565，嵌入式平台习惯用RGB888.
(2)有时候手头只有RGB888的颜色值，但是显示部分却只接受RGB565的（有时候反过来），这时候就需要在2种颜色之间做转换。

1.14.16.2、不同分辨率、不同起点坐标下的显示
(1)屏幕分辨率和图像分辨率不同时的显示。我们现在写的代码都是没有考虑的。
(2)图像起点坐标（左上角坐标）不一定在屏幕左上角，也可能在屏幕的任何其他区域，这种情况下画图的函数要做处理来支持。
(3)分辨率不同而且起始坐标不同下，这两个问题组合起来也对画图函数提出了更高要求。

1.14.16.3、bmp图片格式解析及显示
(1)我们当前的图像数据是用Image2LCD工具转过来的。实践中是不可能手工用工具来转的（你想一下Image2LCD也是一个软件，既然它能转，我们也应该可以用软件来转）
(2)bmp格式的图片本身遵照一定的格式来存储的，我们只需按照bmp的解析格式来读取文件就可得到这幅图片的图像数据的二进制，直接拿去显示。（这就是图片文件的本质）

1.14.16.4、jgp、png、gif等压缩图片的解码和显示
(1)对于以上压缩格式的图片是不能直接解析的，必须用相应的库来解压缩图片之后才能拿来显示。
(2)不同的格式的图片其压缩算法不同，解压缩算法自然也不同。开源社区中每种压缩格式都有个对应的库，库里提供了这种格式的压缩和解压缩函数，我们只需要移植这个库并且调用它来压缩或解压缩即可。

1.14.16.5、图片缩小和放大显示
(1)图片数据源本来是400×200的，但是显示时我希望显示成100×50的，这时候就要显示函数后台对源图像进行先缩小，然后再显示。这时候就需要一个缩小算法。（譬如最简单的算法就是抽点采样）
(2)图片数据源是100×50的，但是显示时希望全屏显示（800×480），这时候就需要对源图像进行放大然后再显示（当然了显示出来图像清晰度肯定比较低），这时候就需要一种放大算法（譬如插点方式）

1.14.16.6、显示动画
(1)动态刷屏形成动画
(2)立体3D图像显示（伪3D）





















