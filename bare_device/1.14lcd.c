
1.14.1.1、什么是LCD
	(1) LCD(Liquid Crystal Display)
	(2) 液晶材料: 可以在电信号的驱动下液晶分子进行旋转, 旋转时会影响透光性	
		// 背光 液晶分子旋转(透光) (彩色)滤光片
	(3) 被动发光(LCD)和主动发光(LED, CRT)

1.14.1.2、其他主流显示设备	// 	CRT、等离子、LCD、LED、OLED	

1.14.1.4、LCD的发展史和种类	//	TN/STN/TFT

1.14.2.1、从电平角度来讲本质上都是TTL信号	// ttl电平(+5v:1, 0v:0)	-- cmos电平
	(2) SoC的lcdc和显示器的硬件接口都是TTL电平	// 直接对接, 软排线
	(3) TTL电平传输距离有限	// 主机SoC(TTL) ->VGA-> LCD屏幕(TTL)

// 各种设备之间相连都需要接口, lcd接口数据量大, 接口复杂(数据量, 传输距离)

1.14.2.2、各种接口	// TTL、LVDS、EDP、MIPI -- 传输速率, 距离, 抗干扰, 适配性

1.14.2.3、RGB接口详解(参考数据手册P1207页时序图)
	(1) VD[23:0]: 数据线
	(2) HSYNC: 水平同步信号
	(3) VSYNC: 垂直同步信号	// 时序信号线, 为了让LCD能够正常显示给的控制信号
	(4) VCLK:  像素时钟		// LCD工作时需要主板控制器给LCD模组一个工作时钟信号，就是VCLK
	(5) VDEN:  数据有效标志	// 时序信号，和HSYNC、VSYNC结合使用
	(6) LEND:  行结束标志	// 时序信号，非必须，譬如x210接口就没有

1.14.3.1、像素	// pixel

1.14.3.2、扫描	// 刷新率
	(1) 扫描: 将颜色数值写入屏幕中所有像素	// 不是s型填充 -- lcd不需要扫描

1.14.3.3、驱动器和控制器
	(1) lcd驱动器一般和lcd显示面板集成在一起	
		// Samsung做面板, 面板通过电信号控制液晶分子旋转透光

	(2)	/*驱动器*/由专门的IC厂商生产
		// lcd驱动器由数字接口接收的控制信号, 给面板提供控制液晶分子的模拟电信号

	(3)	集成厂商买来面板和驱动器后集成在一起做成lcd屏幕	// aoc

	(4)	lcd控制器一般集成在SoC内部, 通过数字接口向lcd驱动器提供控制像素显示的数字信号
		//lcd controler的关键在于时序, 按照一定的时序和lcd驱动器通信
		//lcd controler受SoC控制, SoC会从内存中拿像素数据给lcd controler并最终传给lcd驱动器

	// warning: lcd driver

1.14.3.4、显存
	(1) step1: cpu init lcd controler, /*lcd controler*/和/*显存*/构成映射	// -- 建立显示体系
	(2) step2: cpu将要显示的图像丢到显存中	// 硬件自动响应

	// cpu停止, 外设iis的mclk和bclk仍有时钟信号

1.14.5.2、LCD显示一帧图像的过程
	(1) 一帧分为多行, 一行分为多个像素, 然后逐个像素去显示	//一帧图像就是多个像素组成的矩阵
	(2) lcd控制器和驱动器之间一次只能传一个像素点的显示数据, 所以一帧图像是/*串行*/依次被显示, 
		不是同一时间同时显示

1.14.5.3、为了向前兼容出现的六个时序参数
	HSPW 水平同步信号脉宽
	HBPD 水平同步信号前肩	// 一帧显示完, 移动到帧首
	HFPD 水平同步信号后肩	// 一行显示完, 移动到行首
	VSPW 垂直同步信号脉宽
	VBPD 垂直同步信号前肩
	VFPD 垂直同步信号后肩

	(1) 一行的通信过程是这样的：LCD控制器先发送一个HSYNC高电平脉冲（脉冲宽度是HSPW），
		脉冲告诉驱动器下面的信息是一行信息。
		然后开始这一行信息，这一行信息包括3部分：HBPD+有效行信息+HFPD。
		其中前肩和后肩都属于时序信息（和LCD屏幕具体有关），有效行信息就是横向分辨率。
		所以你可以认为一行总共包含4部分：HSPW+HBPD+有效行信息+HFPD。
	(2) 一帧图像其实就是一列，一列图像由多个行组成，每行都是上面讲的这个时序。
	(3) 一帧图像的通信过程是这样的：整个帧图像信号分为4部分：VSPW+VBPD+帧有效信号+VFPD。
		VSPW是帧同步信号宽度，用来告诉驱动器一帧图像要开始了；VBPD和VFPD分别是垂直同步信号前后肩。
	(4) 必须说明：这6个参数对于LCD显示器其实本来是没用的，这些信号其实是老式的CRT显示器才需要的，LCD本身不需要，
		但是出于历史兼容性要求，LCD选择了兼容CRT显示器的这些时序要求，所以理解LCD显示器时序和编程时，用CRT的方式来理解不会错。
	(5) 要注意，这几个时序参数本身是LCD屏幕本身的参数，与LCD控制器无关。
		所以同一个主板如果接的屏幕不一样则时序参数设置也会不同。
		这些参数的来源一般是：第一，厂家会直接给出，一般以实例代码的形式给出；第二，来自于LCD的数据手册。
	    第一种方式，查看九鼎的210裸机教程（x210v3裸机开发教程\src\template-framebuffer-font\source\hardware\s5pv210-fb.c的第774行）
			.h_fp			= 210,		// 160-210-354
			.h_bp			= 38,		// 46
			.h_sw			= 10,		// 1-40
			.v_fp			= 22,		// 7-22-147
			.v_fpe			= 1,
			.v_bp			= 18,		// 23
			.v_bpe			= 1,		
			.v_sw			= 7,		// 1-20
	第二种方式，查看LCD数据手册（X210光盘资料\A盘\DataSheet\AT070TN92.pdf）

	补充：
	(1) 注意这些数字的单位。H开头的三个单位都是DCLK(像素时钟),V开头的三个单位是TH	// 参数的单位和像素时钟有关
	(2) 这些时序参数如果没设置好会影响什么？屏幕会跑偏

1.14.7.1、颜色相关
	(1) 像素(pixel)
	(2) 像素间距(pitch)		// 影响屏幕的最佳观看距离
	(3) 像素深度(bits per pixel, bpp)	// RGB565(假彩色)、RGB888(真彩色)、ARGB(α表示透明度)
	(4)	颜色是主观存在(红绿色盲), 颜色的本质决定于光的波长
	(5) 光的波长是连续的, 颜色也是连续的	// 计算机中颜色是离散的
	(6)	三元色(三基色)RGB, 组合所有颜色

1.14.9.S5PV210的LCD控制器	// lcd厂商固定, lcd控制器相似
1.14.9.1、FIMD结构框图
	(1) s5pv210的LCD控制器叫FIMD, FIMD是210内部和图像处理相关的一些部件, 
		在摄像头等和图像处理有关的部分都可以有关联
	(2) FIMD在内部与AHB总线等相连接, 在外部提供RGB接口、I80接口、YUV接口
		与外部相连接，我们实际使用的是RGB接口

	// RGB I80显示器使用, ITU摄像头使用

1.14.9.2、虚拟屏幕叠加（数据手册P1194）
	(1) 虚拟屏幕: 屏幕上显示出来的场景是由多个屏幕显示叠加在一起的效果
		/*新闻联播、各个电视台台标、下方飘动的字幕新闻*//*叠加后的图像发布后为一幅图像*/
	(2) S5PV210的LCD控制器中有5个虚拟屏幕Window0到Window4 
	(3) 虚拟屏幕不存在于真实而存在于内存中(显存), 有几个显存区域就有几个
		虚拟屏幕, /*多个虚拟*/屏幕都被映射到/*一个真实*/的显示屏上面	// 寄存器配置覆盖关系
	(4) 使用虚拟屏幕而不是整个LCD使用一个显存优点:
		第一，可以保证不污染源图像，方便程序处理
		第二，可以减少屏幕刷新/*对应写内存操作*/，提高显示效率，减少CPU工作量

1.14.9.3、虚拟显示（数据手册P1206）
	(1) 如何实现在小分辨率的屏幕上(真实)显示大分辨率的图像
	(2) 细节上，我们需要屏幕上看到不同图像时，需要对显存区域进行刷新。
		即使我们只需要屏幕显示移动一点点，
		整个屏幕对应的显存空间也需要整个重新刷新，工作量和完全重新显示一幅图像是一样的
		这个显然不好，这样CPU刷新屏幕的工作量太大了，效率很低。
	(3) 如何能够在显示一个大图片的不同区域时让CPU刷新屏幕工作量减少
		具体做法就是在内存中建立显示缓存的时候实际建立一个很大的区域，
		然后让LCD去对应其中的一部分区域作为有效的显示区域
		将来要显示大图像时，直接将大图像全部一次性加载入显示缓存区，
		然后通过移动有效显示区域就可以显示大图像的不同区域了
		// 如: 图像动画移动
		// 一般需要进行图像运算

1.14.9.4、主要寄存器简介
	// LCD controller maximum 100MHz 	// VIDCON0 
	// 显示器 26.3    33.3    46.8

	// miscellaneous sfrs: display_control 0xE010_7008

	// 物理屏幕大小  // VIDTCON2
	// 虚拟屏幕大小  // VIDOSD0A VIDOSD0B  -- 显存空间大小

1.14.10.LCD编程实战1-LCD控制器初始化
	(1) 要想LCD工作，必须给LCD屏幕和显存之间建立一个映射
	   （映射是在CPU初始化LCD控制器来完成的）

1.14.11.LCD编程实战2-显示像素&刷背景
	(1) 显示像素		// 基本驱动函数
	(2) 刷背景色

	// static
	// static incline

1.14.12.LCD编程实战3-横线竖线斜线&画圆
	(1) 画横线&竖线
	(2) 斜线

1.14.13.LCD编程实战4-写英文中文字符

1.14.14.LCD编程实战5-画图
1.14.14.1、图片显示分析
	(1) 图像是彩色的，而之前的文字、图形都是单色的。之前的图形文字绘制函数都
		有个color参数，就是传给显存告诉它这个像素的显示颜色
	(2) 一副分辨率是800×480，BPP是24的图片，实际上就是800×480×3字节的数据。
		将来写代码将图片显示到LCD中时，图片将会以 unsigned char pic_data[800×480×3]的形式出现。

1.14.14.2、Image2LCD使用简介	// Image2LCD软件使用的注意事项

1.14.14.3、画图函数的编写

1.14.15.2、RGB的像素顺序调整
	(1) 图片中红色的变成了蓝色、蓝色的变成了红色，这就说明RGB顺序反了	// 单色RGB没有出现颜色翻转情况
	(2) 解决方案一：重新使用Image2LCD来取模，取模时RGB顺序对调。
	(3) 解决方案二：不重新取模，改代码，在color形成的时候调换顺序。

1.14.15.3、小分辨率图片显示
	(1) 本质上大小分辨率的图像显示都是一样的，都是：都是在图像的每个像素
		点对应的显存中填入相应的颜色值即可

1.14.16.未完成事项展望
1.14.16.1、RGB565和RGB888	// 相互转换

1.14.16.2、不同分辨率、不同起点坐标下的显示
	(1) 屏幕分辨率和图像分辨率不同时的显示, 我们现在写的代码都是没有考虑的
	(2) 图像起点坐标（左上角坐标）不一定在屏幕左上角，也可能在屏幕的任何其他区域，
		这种情况下画图的函数要做处理来支持。
	(3) 分辨率不同而且起始坐标不同下，这两个问题组合起来也对画图函数提出了更高要求。

1.14.16.3、bmp图片格式解析及显示
	(1) 当前的图像数据是用Image2LCD工具转换得到, 实践中是不可能手工用工具来转的
	   （你想一下Image2LCD也是一个软件，既然它能转，我们也应该可以用软件来转）
	(2) bmp格式的图片本身遵照一定的格式来存储的, 我们只需按照bmp的解析格式来读
	    取文件就可得到这幅图片的图像数据的二进制，直接拿去显示。（这就是图片文件的本质）

1.14.16.4、jgp、png、gif等压缩图片的解码和显示
	(1) 对于以上压缩格式的图片是不能直接解析, 必须用相应的库来解压缩图片之后才能拿来显示	// 开源库

1.14.16.5、图片缩小和放大显示	// 放大缩小算法(如: 抽点, 插点)


