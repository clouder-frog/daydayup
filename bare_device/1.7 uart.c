
	// 相同根数的通信线, 差分信号要快(1个发送周期更短)

	// 异步、串行、差分，譬如USB和网络通信

7.2.1、串口通信的特点：异步、电平信号、串行

7.2.4、起始位、数据位、奇偶校验位、停止位
	这些通信参数包括：波特率、数据位(8bit -- ASCII编码)、奇偶校验位(无)、停止位(1bit)、(串口通信中起始位定义是唯一的，所以一般不用选择)

7.3.3、信息以二进制流的方式在信道上传输		// 二进制流
	(1)接收方通过定时(起始时间由读到起始位标志开始, 间隔时间由波特率决定)读取通信线上的电平高低来区分发送是1还是0
		依次读取数据位、奇偶校验位、停止位, 停止位就表示这一个通信单元(帧)结束
		然后中间是不定长短的非通信时间(发送方有可能立即发送第二帧, 也可能推迟很久发送, 这就叫异步通信), 下来就是第二帧

	(2)串口发送(数字、文本、命令)都要先对发送内容进行编码(ASCII码编码), 编码成二进制在进行逐个位的发送(二进制流的形式) 

	(3)DB9接口中有9根通信线, GND、Tx、Rx, 剩余6根都是和流控有关

	(4)universal asynchronous reciver and transmitter(uart), 通用异步收发器(串口)

7.4.1、S5PV210的串口控制器工作原理框图
	(2)串口控制器是接在APB总线上, 计算uart controller的src clock是以APB总线时钟计算

	(3)transmitter由发送缓冲区和发送移位器构成
		发送信息时, 首先将信息进行/*编码*/(一般用ASCII码)成二进制流		// printf("123");
		将编码后的一帧数据(一般是8位)写入发送缓冲区, 发送移位器会自动从发送缓冲区中读取一帧数据, 然后自动移位, 将其发送到Tx通信线上

7.5.3、IrDA模式及其用法	// 向串口写数据, 数据以红外光的形式向外发射(需要硬件支持)

7.6.1、串行通信与中断的关系
(1)串口通信分为发送/接收2部分, 发送方一般不需要中断即可完成发送; 接收方一般使用中断来接收	// 串口通信是异步的
	for( )
	{
		while(empty flag)
		{
			
		}
	}

7.6.2、210串行通信接口的时钟设计
	(1)串口通信为什么需要时钟？因为串口通信需要一个固定的波特率，所以transmitter和receiver都需要一个时钟信号。
	(2)时钟信号从哪里来？源时钟信号是外部APB总线（PCLK_PSYS，66MHz）提供给串口模块的（这就是为什么我们说串口是挂在APB总线上的）
		然后进到串口控制器内部后给波特率发生器（实质上是一个分频器），在波特率发生器中进行分频，分频后得到一个低频时钟，
		这个时钟就是给transmitter和receiver使用的。
	(3)串口通信中时钟的设置主要看寄存器设置。
		重点的有：寄存器源设置（为串口控制器选择源时钟，一般选择为PCLK_PSYS，也可以是SCLK_UART），还有波特率发生器的2个寄存器。
	(4)波特率发生器有2个重要寄存器：UBRDIVn和UDIVSLOTn，其中UBRDIVn是主要的设置波特率的寄存器，UDIVSLOTn是用来辅助设置的，目的是为了校准波特率的。

7.7.S5PV210串行通信编程实战1
7.7.1、整个程序流程分析
(1)整个串口通信相关程序包含2部分：uart_init负责初始化串口，uart_putc负责发送一个字节
7.7.2、串口控制器初始化关键步骤
(1)初始化串口的Tx和Rx引脚所对应的GPIO（查原理图可知Rx和Rx分别对应GPA0_1和GPA0_0）
(2)GPA0CON（0xE0200000），bit[3:0] = 0b0010	bit[7:4] = 0b0010	
(3)初始化这几个关键寄存器UCON0 ULCON0 UMCON0 UFCON0 UBRDIV0 UDIVSLOT0
1.7.7.3、主要的几个寄存器
(1)ULCON0 = 0x3		// 0校验位、8数据位、1停止位
(2)UCON = 0x5		// 发送和接收都是polling mode【轮询】
(3)UMCON0 = 0x0		// 禁止modem、afc
(4)UFCON0 = 0x0		// 禁止FIFO模式
(5)UBRDIV0和UDIVSLOT0和波特率有关，要根据公式去算的


7.8.3、波特率的计算和设置
(1)第一步，用PCLK_PSYS和目标波特率计算DIV_VAL: DIV_VAL = (PCLK / (bps x 16))-1
(2)第二步，UBRDIV0寄存器中写入DIV_VAL的整数部分
(3)第三步，用小数部分*16得到1个个数，查表得uBDIVSLOT0寄存器的设置值
7.8.4、串口发送和接收函数的编写
(1)写发送函数，主要发送前要用while循环等待发送缓冲区为空才能发送。
7.8.5、综合调试
注意Makefile的修改。
7.8.6、扩展练习-更改波特率后再调试
自己练习。注意程序中改了波特率后，SecureCRT也要相应修改，不然收不到东西。

7.9.uart stdio的移植1
7.9.1、什么是stdio
(1)#include <stdio.h>
(2)stdio：standard input output，标准输入输出
(3)标准输入输出就是操作系统定义的默认的输入和输出通道 一般在PC机的情况下，标准输入指的是键盘，标准输出指的是屏幕
【每一个进程都有三个流：标准输入输出是操作系统可以定义的两个流，标准错误】
(4)printf函数和scanf函数可以和底层输入/输出函数绑定，然后这两个函数就可以和stdio绑定起来。
	也就是说我们直接调用printf函数输出，内容就会被从标准输出输出出去。
(5)在我们这里，标准输出当然不是屏幕了，而是串口。标准输出也不是键盘，而是串口。

7.9.2、printf函数的工作原理
(1)printf函数工作时内部实际调用了2个关键函数：一个是vsprintf函数（主要功能是格式化打印信息，最终得到纯字符串格式的打印信息等待输出），
	另一个就是真正的输出函数putc（操控标准输出的硬件，将信息发送出去）

7.9.3、移植printf函数的三种思路
(1)我们希望在我们的开发板上使用printf函数进行（串口）输出，使用scanf函数进行（串口）输入，就像在PC机上用键盘和屏幕进行输入输出一样。因此需要移植printf函数/scanf函数
(2)我们说的移植而不是编写，我们不希望自己完全从新编写而是想尽量借用也有的代码（叫移植）
(3)一般移植printf函数可以有3个途径获取printf的实现源码：最原始最原本的来源就是linux内核中的printk。难度较大、关键是麻烦；
	稍微简单些的方法是从uboot中移植printf；更简单的方法就是直接使用别人移植好的。
(3)我们课程中使用第三种方法，别人移植好的printf函数来自于友善之臂的Tiny210的裸机教程中提供的。


7.9.4、移植好的printf介绍
参考视频中讲解。【uartstdio的移植1.mp4 移植2.mp4 Makefile的修改】
objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o vsprintf.o
定义变量objs，保证所有的源文件都能被编译
objs := xxx.o xxx.o xxx.o
uart.bin: $(objs)              //在Makefile中定义一个变量，再去引用这个变量【$ 引用】
libc.a: $(objs)
目标是libc.a : .a表示是一个库，相当于Windows中的静态链接库.lib 
            .so Linux中动态链接库，Windows中叫 .dll

7.10.uart stdio的移植2
7.10.1、修改Makefile进行printf移植
7.10.2、Makefile及gcc的库文件介绍
7.10.3、多文件夹裸机工程的结构解析
7.10.4、编译运行及测试

7.11.uart stdio的移植3
7.11.1、在移植后的uart stdio项目中添加link.lds链接脚本，指定连接地址到0xd0020010
7.11.2、gcc可变参数及va_arg介绍
(1)printf函数中首先使用了C语言的可变参数va_start/va_arg/va_end；
(2)建议大家先去baidu“C语言可变参数”，然后按照别人的教程、博客实际写几个简单的变参的使用示例，先明白可变参数怎么工作，然后再来分析这里。
7.11.3、vsprintf函数详解
printf
	vsprintf
		vsnprintf
			number
vsprintf函数的作用是按照我们的printf传进去的格式化标本，对变参进行处理，然后将之格式化后缓存在一个事先分配好的缓冲区中。
printf后半段调用putc函数将缓冲区中格式化好的字符串直接输出到标准输出。

7.12.串口实验烧录问题总结
7.12.1、usb下载的问题
(1)USB下载时在Win7 X64系统下，下载前面章节的小代码时没问题，下载串口通信的小代码时也没问题，下载uart stdio的移植就有问题了。
有时候下载不动、有时候能下载但是不运行、有时候又正常下载运行。我已经试过下载其他的dnw或dnw驱动更新，都无法解决。
7.12.2、SD卡镜像烧录
(1)SD卡烧录镜像做裸机实验，在第四部分1.4.2节中有讲过。
(2)本次我们在Windows下烧录（linux下的烧录参考以前的）
(3)Windows下烧录镜像是使用九鼎提供的工具（X210光盘资料\A盘\tools\x210_Fusing_Tool.exe），注意运行时右键“以管理员身份运行”。
7.12.3、启动方式设置
(1)X210开发板的启动方式的选择，请参考1.2.11节。其实就是OM5的问题，OM5设置为VCC则从USB启动，OM5设置成GND，则从iNand/SD卡启动。
(2)开发板选择从iNand启动后，还要确保iNand中uboot是被擦除的。
(3)关于如何破坏uboot的问题，大家可以参考之前课程中讲的在linux/android系统中破坏uboot的方法
	我之前讲过在uboot中破坏uboot的方法：movi write u-boot 0x30000000
	很多同学反映擦除后错乱，进不了系统也从SD卡启动不了，只能通过USB刷机来解决
	后来又分析，改为：mw 0x30000000 0x0 0x100000，然后再movi write u-boot 0x30000000
。但是反馈结果有人说可以了，有人说还是不行・・・・・・・
(4)不管怎么擦除uboot，总之首先确保你的板子SD卡启动是成功的。怎么确保？
	先用SD卡烧录启动之前的LED闪烁的项目，确保看到现象就证明烧录SD卡方法和启动SD卡都成功了，再做本节课的实验。
7.12.4、链接脚本的影响
7.12.5、bin文件大于16KB怎么办？
通过USB下载最多也只能下载96KB大小的bin，如果bin大于96KB肯定SRAM放不下会出错。如果用SD卡启动，那么mkv210_image.c决定了bin文件最大不能超过16KB。
超过了怎么办？2种解法：
第一，在USB下载时，可以先下载一个x210_usb.bin，然后再将裸机程序连接到0x23E00000，然后再修改dnw中下载地址，将裸机代码下载到0x23E00000运行。
（这时不需要重定位了）
第二，在SD卡启动时，将整个裸机工程分为2部分；第一部分大小16KB以内，
第二部分放剩下的（放在SD卡的后面的某个扇区开始的位置，譬如放在第50个扇区开始的位置），
然后在裸机代码中进行重定位（SD卡中重定位）。这个暂时没讲，以后如果有用到就讲。





