
3.4.1.1、main函数由谁调用		// 程序运行时用加载器
	(1) OS下的应用程序在main执行前
		需要先执行一段引导代码(链接时，链接器自动添加)，再执行main
	(2) 运行时的加载器		// 程序运行：./a.out，代码中用exec族函数
		加载器是操作系统中的程序，负责将程序加载到内存中去执行
	(4) argc和argv的传参如何实现		// char *env[]

3.4.1.2、程序如何结束
	(1) 正常终止：return、exit()、_exit()
	(2) 非正常终止：自己或他人发信号终止进程

3.4.1.3、atexit注册进程终止处理函数		// atexit(void (*func)(void))
		return、exit()会执行进程终止处理函数, _exit()不执行

3.4.2.1、环境变量		// export命令：进程本身有一份环境变量(字符串数组)
	(2) 进程环境表, 字符串数组，用environ变量指向它
		// extern char **environ;	while (NULL != environ[i])
	(3) 程序中用到了环境变量那么程序就和操作系统环境有关
		// 相同程序，不同执行结果
	(4) 获取指定环境变量函数getenv		// getenv("PATH")

3.4.2.2、进程运行的虚拟地址空间
	(1) 操作系统中每个进程在独立地址空间中运行
	(2) 每个进程的逻辑地址空间均为4GB		// 0-1G为OS，1-4G为应用
	(4) 虚拟地址到物理地址空间的映射
		// app都链接在0地址处，运行时由OS转换地址
		// 进程隔离，提供多进程同时运行
		// 智能手机动态装软件

3.4.3.1、什么是进程		// 动态的 过程
	// 进程就是程序的一次运行过程，一个静态的可执行程序a.out 的 一次运行过程
	// ./a.out从运行到结束就是一个进程

3.4.3.2、进程ID
	(1) getpid、getppid、getuid、geteuid、getgid、getegid
	(2) 实际用户ID和有效用户ID区别

3.4.3.3、多进程调度原理
	(1) OS维护一份进程调度表
	(2) 实际上现代操作系统最小的调度单元是/*线程*/而不是进程

3.4.4.2、fork的内部原理
	(5) fork的返回值在子进程中等于0，在父进程中等于本次fork创建的子进程的进程ID

	// ps -aux | grep  "1990"

3.4.5.1、子进程继承父进程中打开的文件

3.4.5.2、父子进程各自独立打开同一文件实现共享

3.4.6.1、进程的诞生
	(1) 进程0和进程1
	(2) fork、vfork

3.4.6.2、进程的消亡
	(2) 进程在运行时需要消耗系统资源(内存、IO)		// vi .file.c.swp
	(3) linux系统设计时规定：每一个进程退出时，操作系统会自动回收这个进程涉及到
		的所有的资源(如：free内存，close文件)
	(4) 操作系统只是回收了这个进程工作时消耗的内存和IO，进程本身的8KB内存
		由父进程来回收

3.4.6.3、僵尸进程
	(1) 子进程先于父进程结束，未被父进程回收
	(3) 父进程可以使用wait或waitpid以显式回收子进程的剩余待回收内存资源
		并且获取子进程退出状态。
		父进程结束时会回收子进程(僵尸进程)的剩余待回收内存资源

3.4.6.4、孤儿进程
	(1) 父进程先于子进程结束，父进程修改为进程1(init进程)

3.4.7.1、wait的工作原理
	(1) 子进程结束时，系统向其父进程发送SIGCHILD信号
	(2) 父进程调用wait函数后阻塞
	(3) 父进程被SIGCHILD信号唤醒然后去回收僵尸子进程
	(4) 父子进程之间是异步的，SIGCHILD信号机制就是为了解决父子进程之间的异步
		通信问题，让父进程可以及时的去回收僵尸子进程
	(5) 若父进程没有任何子进程则wait返回错误

3.4.7.2、wait实战编程
	(1) wait用来回收子进程资源，回收同时可以获取被回收子进程的pid和退出状态
		// int wait(int *status)
		// int i;
		// wait(&i)

	(2) WIFEXITED宏用来判断子进程是否正常终止(return、exit、_exit退出)
		WIFSIGNALED宏用来判断子进程是否非正常终止(被信号所终止)
		WEXITSTATUS宏用来得到正常终止情况下的进程返回值的
		// 特定宏来解析status

3.4.8.1、waitpid和wait差别
	(1) 基本功能一样，都是用来回收子进程
	(2) waitpid可以回收指定PID的子进程
	(3) waitpid可以阻塞式或非阻塞式两种工作模式

3.4.8.3、代码实例
	(1) ret = waitpid(-1, &status, 0);		// -1表示任意pid; 0阻塞式;
	(2) ret = waitpid(pid, &status, 0);		
	(3) ret = waitpid(pid, &status, WNOHANG);	// 非阻塞式

3.4.9.2、exec族的6个函数介绍
	(1) execl和execv
	(2) execlp和execvp
	(3) execle和execvpe

3.4.11.3、system函数简介		// fork + exec 原子操作

3.4.12.进程关系
	(1) 无关系
	(2) 父子进程关系
	(3) 进程组(group)由若干进程构成一个进程组
	(4) 会话(session)进程组的组

3.4.13.1、进程查看命令ps
	(1) ps -ajx	显示各种有关的ID号
	(2) ps -aux	显示进程各种占用资源

3.4.13.2、向进程发送信号指令kill	// kill -9 pid

3.4.13.3、何谓守护进程		// daemon -- xxxd
	(2) 长期运行: 一般是开机运行直到关机时关闭
	(3) 与控制台脱离: 普通进程都和运行该进程的控制台相绑定
					  如果终端被强制关闭则这个终端中运行的所有进程都被会关闭
					  背后的问题还在于会话	 // tty = ? or tty = ps/4
	(4) OS的系统服务一般通过daemon的方式实现(如：系统自带的nfs服务)

3.4.13.4、常见守护进程
	(1) syslogd：系统日志守护进程，提供syslog功能
	(2) cron：用来实现操作系统的时间管理		// 实现定时执行程序

3.4.14.1、任何一个进程都可以将自己实现成守护进程
	(1) 创建子进程，父进程退出
	(2) setsid()创建新的会话期，脱离原会话、原进程组、原控制台的控制
	(3) chdir()将当前工作目录设置为/
	(4) umask(0)取消任何文件权限屏蔽
	(5) 关闭所有文件描述符		// 脱离控制终端，fd0 1 2没有作用
	(6) 将0、1、2定位到/dev/null

	// 守护进程不能printf，如何记录调试信息 -- syslog

3.4.15.1、openlog、syslog、closelog
	(1) 一般log信息都在操作系统的/var/log/messages这个文件中存储着
		但是ubuntu中是在/var/log/syslog文件中的

3.4.15.4、syslog的工作原理
	(1) 守护进程syslogd负责进行日志文件的写入和维护	// 开机运行，关机时才结束
	(2) syslogd是独立于任意一个进程而运行，当前进程通过调用openlog打开一个
		和syslogd相连接的通道，然后通过syslog向syslogd发消息，然后由syslogd来
		将其写入到日志文件系统中
	(3) syslogd是一个日志文件系统的/*服务器进程*/，提供日志服务
		任何需要写日志的进程都可以通过openlog/syslog/closelog这三个函数来
		利用syslogd提供的日志服务			// 操作系统的服务式的设计
	
	// 一般调用过程，程序运行时打开openlog()，程序运行结束关闭
	// openlog()常用参数LOG_PID

3.4.16.让程序不能被多次运行		// 单例运行
	(1) 用一个文件的存在与否来做标志

3.4.17.1、为什么需要进程间通信		// 两个不同进程处于不同地址空间

3.4.17.2、什么样的程序设计需要进程间通信	// 一般使用单进程(多线程)

3.4.17.3、linux内核提供多种进程间通信机制
	(1) 无名管道和有名管道
	(2) SystemV IPC：信号量、消息队列、共享内存		// 实质是内核提供公共内存
	(3) Socket域套接字
	(4) 信号

3.4.18.1、管道（无名管道）
	(1) 原理：内核维护的一块内存，有读端和写端（管道是单向通信的）
	(2) 方法：父进程创建管道后fork子进程，子进程继承父进程的管道fd
	(3) 限制：只能在父子进程间通信、半双工
	(4) 函数：pipe、write、read、close

3.4.18.2、有名管道（fifo）
(1) 原理：实质也是内核维护的一块内存，表现形式为一个有名字的文件
(2) 方法：固定一个文件名，2个进程分别使用mkfifo创建fifo文件
		  然后分别open打开获取到fd，然后一个读一个写
(3) 限制：半双工	// 不限制父子进程，任意两个进程
(4) 函数：mkfifo、open、write、read、close
