
1. linux中的文件IO：在linux下如何操作文件、linux下一切皆是文件。
					什么是文件，文件在OS下如何被操作

2. 文件属性：文件相关的属性设置（跟属性设置相关的API函数）如何获取一个文件的属性，如何更改一个文件的属性

3. 获取系统信息(系统时间、随机数、proc中的文件)：如何在应用层通过OS的API获取系统的一些信息 

4. 进程（进程环境、进程控制、进程关系、守护进程、进程间通信）

5. 信号：如何用信号传递信息，如何捕获一个信号（给这个信号绑定一个执行函数），信号是GUI体系的基础（Qt有信号与槽的概念）

6. 高级IO：多路复用IO，异步

7. 线程：多线程在多核CPU有天然的优势

8. 网络编程：很多网络服务器都是linux。linux网络功能很强大
====================================================================================
====================================================================================


3.1.1.1、什么是应用编程
	典型的嵌入式产品的研发过程就是
		(1) 让linux系统在硬件上跑起来(系统移植工作)
		(2) 基于linux系统来开发应用程序实现产品功能

	基于linux去做应用编程, 其实就是通过调用/*linux的系统API*/来实现
	如何使用/*linux系统API*/和/*C库函数*/来实现一定的功能

3.1.1.4、什么是文件IO		// 读写文件

3.1.2.1、什么是操作系统API
	(1) linux系统提供, 由应用层程序来使用
	(2) 应用层程序通过调用API来/*调用操作系统*/中的各种功能
	(3) //学习一个操作系统，其实就是学习使用这个操作系统的API

3.1.2.2、linux常用文件IO接口
	(1) open、close、write、read、lseek

3.1.2.3、文件操作的一般步骤
	(1) 先open打开一个文件，得到一个文件描述符，然后对文件进行读写操作(或其他操作)，最后close关闭文件

	(3) 文件是存在/*块设备*/中(硬盘、nandflash、sd卡)的文件系统中，这种文件叫静态文件
		open打开一个文件时，linux内核做的操作包括：
		①内核在/*进程(当前正在运行的程序)*/中建立了一个打开文件的数据结构, 记录下打开的文件
		②内核在内存中申请一段内存，并且将静态文件的内容从块设备中读取到内存中特定地址管理存放(叫动态文件)
        //内核申请还是某个进程自己申请 -- 2018-4-16 09:07:01

	(4) 当close关闭动态文件时, close内部/*内核*/将内存中的动态文件的内容去更新(同步)块设备中的静态文件

3.1.2.4、/*重要概念*/ 文件描述符 //文件描述符 是 针对 当前进程 而言
	(1) 文件描述符其实实质是一个数字，这个数字在/*一个进程中*/表示一个特定的含义
		open打开一个文件时: 操作系统在内存中构建了一些数据结构来表示这个动态文件
		然后返回给应用程序一个数字作为文件描述符, //这个数字就和内存中维护这个动态文件的数据结构绑定
	(2) 文件描述符：文件描述符就是用来区分/*一个程序*/打开的多个文件
	(3) */文件描述符的作用域当前进程

	//重新fork一个进程来打开其他进程已经打开的文件？-- 2018-4-7 18:31:36

3.1.4.open函数的flag详解1	/*1.读写权限问题; 2.接续截断问题*/
	(1) 读写权限: O_RDONLY, O_WRONLY, O_RDWR
	(2) 创建权限：O_CREAT						// 1,可以配合O_EXCL使用; 2, 参数mode: 0666
	(3) 接续权限：O_APPEND, O_TRUNC				// append 附加; 添加; 贴上
	(4) 阻塞权限：O_NONBLOCK, O_SYNC
	
	/*打开一个文件默认就是阻塞式*/, 如果希望以非阻塞的方式打开文件, 则flag中要加O_NONBLOCK标志
	//只用于设备文件, 而不用于普通文件
	//设备文件：Linux中的一些硬件设备，这些硬件设备在Linux中是以文件的方式来访问(称之为设备文件)
	//设备文件有阻塞式和非阻塞式两种方式
	//在编写驱动时来实现阻塞式和非阻塞式
	//驱动如何封装为设备文件
	
	(1) write阻塞等待底层完成写入才返回到应用层 //添加O_SYNC标志
	(2) /*不添加O_SYNC*/时write只是将内容//写入底层缓冲区即可返回
		然后底层(操作系统中负责实现open、write这些操作的那些代码，也包含OS中读写硬盘等底层硬件的代码)
		在合适的时候会将buf中的内容一次性的同步到硬盘中, 这种设计是为了提升硬件操作的性能和寿命

3.1.6.文件读写的一些细节
    3.1.6.1、errno和perror
        (1) errno(error number)linux系统中对各种常见错误编号, 当函数执行错误时, 函数会返回一个特定的errno编号
        (2) /*errno是由OS来维护的一个全局变量*/ -- /*OS给封装起来, 上层是不能对这些全局变量进行操作*/
        (3) errno本身实质是一个int类型的数字, 每个数字编号对应一种错误 // also 对应一个 Success

		// ret = close(fd);		perror("func@close()")		-- func@close(): Success

	3.1.6.2、exit、_exit、_Exit退出进程		// 一般情况下, 进程 == 程序
		(1) 在main函数中用return，一般原则是程序正常终止return 0
		(2) 正式终止/*进程(程序)*/应该使用/*exit(c库函数)*/或者/*_exit或者_Exit(linux api)*/

    3.1.6.2、read和write的count
        (1) count和ret: count设置字节数, ret实际字节数
        (2) count可以和阻塞非阻塞结合起来
        (3) 需要读取或者写入大文件(譬如2MB), 不会把count设置为 2*1024*1024
            而应该去把count设置为一个合适的数字(譬如2048、4096)	//循环读取或者写入

    3.1.6.3、文件IO效率和标准IO
        (1)文件IO就指的是我们当前在讲的open、close、write、read等API函数构成的一套用来读写文件的体系
            这套体系可以很好的完成文件读写，但是效率并不是最高的 // 考虑到传输成本
        (2)应用层C语言库函数提供了一些用来做文件读写的函数列表，叫标准IO
            标准IO由一系列的C库函数构成(fopen、fclose、fwrite、fread)
            这些/*标准IO函数*/其实是由/*文件IO*/封装而来的 //底层实现仍是: 文件IO
            标准IO封装:
                在应用层添加缓冲机制，这样通过fwrite写入的内容不是直接进入/*内核中的buf*/
                而是在应用层标准IO库自己维护的buf中
                然后标准IO库自己根据//操作系统选择合适的时机(单次write的最佳count), 完成write到内核中的buf
                /*内核中的buf*/再根据硬盘的特性来选择合适的时机去最终写入硬盘中

3.1.7.linux系统如何管理文件
    Linux中/*所有的设备都是以文件形式(设备文件)*/, 驱动所形成的设备文件最终也是通过文件io的方法来操作
    这些/*对文件的操作最终是如何映射到对硬件的操作*/, 也需要对文件管理策略有所了解
    扇区是硬件所能访问的最小的单元, 所以一个扇区内部不能存放两个文件(硬盘喜欢大文件)(文件压缩的一个方面)
    每个扇区都有一个扇区号

    3.1.7.1、硬盘中的静态文件和inode(i节点)
        (2) 硬盘中分为两大区域: 硬盘内容管理表项/* - inode信息表项? */, 真正存储内容的区域
            OS访问硬盘:
                ①是先去读取硬盘/*内容管理表*/, 从中找到要访问的那个文件的扇区级别的信息
                ②然后再用这个信息去查询真正/*存储内容的区域*/

        (3) OS最初拿到的信息是文件名, 最终得到的是文件内容
            第一步就是去查询硬盘内容管理表, 这个管理表中/*以文件为单位*/记录了各个文件的各种信息
            每一个文件有一个信息列表(叫inode，i节点)其实质是一个结构体, 这个结构体有很多元素
            每个元素记录了这个文件的一些信息, 其中就包括文件名、文件在硬盘上对应的扇区号、块号・・・

        */强调: 硬盘管理的时候是以文件为单位
			每个文件一个inode，每个inode有一个数字编号，对应一个结构体，结构体中记录了各种信息

    3.1.7.2、内存中被打开的文件和vnode(v节点)
        (1) 一个程序的运行就是一个进程, 在程序中打开的文件就属于某个进程
            每个进程都有一个数据结构用来记录这个进程的所有信息/*进程信息表*/		// -- task control block
            表中有一个指针会指向一个/*文件管理表*/, 文件管理表中记录了当前进程打开的所有文件及其相关信息
            文件管理表[数组]用来索引各个文件的index: 文件描述符fd
            /*最终(中间还有其他环节)*/找到的是动态文件的管理结构体vnode

        (2) 一个vnode中就记录了一个被打开的文件的各种信息
            通过文件的fd, /*最终*/就可以找到这个文件的vnode进而对这个文件进行各种操作

    3.1.7.3、文件与流的概念
        一个文件中/*N多的个字符*/被依次读出/写入时，这些字符就构成了一个字符流
        */流这个概念是动态的，不是静态的
        编程中提到流这个概念, 一般都是IO相关的, 所以经常叫IO流, 文件操作时就构成了一个IO流

3.1.8.lseek详解
    3.1.8.1、lseek函数介绍
        (1) 文件指针：对一个文件进行读写，需要先打开这个文件，所以读写的所有文件都是动态文件
            //动态文件在内存中的形态就是文件流的形式

        (3) 在动态文件中, 通过/*文件指针filePoint*/来表征这个文件/*正在操作*/的位置 	// -- UI下的光标

            filePoint就是文件管理表[结构体数组]这个结构体里面的一个指针
            filePoint其实是vnode中的一个元素, 这个指针表示当前正在操作文件流的哪个位置
            filePoint不能直接访问, linux系统用/*lseek函数*/来访问这个文件指针

        (5) read和write函数都是从当前文件指针处开始操作, current filePoint会隐式改变

    3.1.8.2、用lseek计算文件长度 // vc中tell函数
        //参数 offset 的含义取决于参数 whence:    //offset can be positive or negative
            1. whence: SEEK_SET -> 文件偏移量: offset
            2. whence: SEEK_CUR -> 文件偏移量: current location + offset
            3. whence: SEEK_END -> 文件偏移量: sizeof(file) + offset

//successful: returns the resulting offset location as [measured in bytes from the beginning of the file]
//error     : retrun -1 and [errno is set] to indicate the error

    3.1.8.3、用lseek构建空洞文件 
        (1) 空洞文件就是这个文件中有一段是空的
        (2) 普通文件中间是不会有空, write时文件指针是依次从前到后去移动
        (3 )打开一个文件后, 用lseek往后跳过一段, 再write写入一段, 就会构成一个空洞文件
        (4) 空洞文件方法有利于/*多线程共同操作文件*/
			创建一个很大的文件, 如果从头开始依次构建时间很长
            有一种思路就是将文件分为多段, 然后多线程来操作每个线程负责其中一段的写入

// -- read write (close open) 可以隐式的改变文件指针 -- all can

// -- 同一个进程多次打开相同文件: O_APPEND只能在write操作关联filePoint, 在read情况下不能关联
// -- 测试一个进程多次打开一个文件 和 多个进程多次打开同一个文件; 在内存中是不是都是同一份拷贝

	// 可以接续写入，可以证明是同一份拷贝 -- 2019-5-8 13:17:31

// -- O_APPEND参数, 文件再执行写入操作的时候会自动跳到文件末尾. 一个进程重复打开应该操作内存中同一份拷贝 \
   -- 文件在内存中只有一份拷贝, 但是被多个file对象所指向, 每个fd又对应一个file对象

3.1.9.多次打开同一文件
    3.1.9.1、重复打开同一文件读取 // 普通文件可以被重复打开, 设备文件？
        (1) fd1和fd2分别读, 不是接续读写
            说明：使用open两次打开同一个文件时, fd1和fd2所对应的/*文件指针*/是不同的, 两个独立的指针
            -- 是两个独立的filePoint(), 还是两个独立的vnode 2018-4-12
            // -- 两个fd对应两个file table(file table对象有一个成员变量:current file offset)
            // -- 指向同一个vnode

            //-- fd就是用来索引/*文件管理表*/中的数组成员-vnode  -- 这两句需证实2018-4-17 08:57:46
            //-- 其中在一个进程中, fd不同则对应的vnode不同, vnode中的filePoint肯定也是不同

            文件指针是包含在动态文件的文件管理表中  // -- file manage table 指的是通过fd索引到的
            所以可以看出linux系统的进程中/*不同fd*/对应的是/*不同文件管理表*/

    3.1.9.2、重复打开同一文件写入 // 两个不同文件描述符对同一个文件进行操作的结果和现象
        (3)default写入方式: 分别写(两个fd对应的current file offset不能相互更新)

    3.1.9.3、加APPEND解决覆盖问题 // coverage
        (1)接续写而不是分别写: 在open时加O_APPEND标志

    3.1.9.4、APPEND的实现原理和其原子操作性说明  //linux文件共享的实现
        (1) O_APPEND为什么能够将分别写改为接续写?  -- filePoint
            分别写的内部原理就是2个fd拥有不同的文件指针, 并且彼此只考虑自己的位移
            //但是O_APPEND标志可以让write内部多做一件事情 \
            就是移动自己的文件指针的同时也去把别人的文件指针同时移动
            也就是说即使加了O_APPEND，fd1和fd2还是各自拥有一个独立的文件指针
            但是这两个文件指针关联起来了，一个动了会通知另一个跟着动
        (2) O_APPEND对文件指针的影响, 对文件的读写是原子的 //-- man手册查看
        (3) 原子操作的含义是：
            整个操作一旦开始是不会被打断的，必须直到操作结束其他代码才能得以调度运行，这就叫原子操作
            每种操作系统中都有一些机制来实现原子操作，以保证那些需要原子操作的任务可以运行

3.1.10.文件共享的实现方式
    3.1.10.2、文件共享的3种实现方式		// 多个文件描述符指向同一个文件
		(1) 同一个进程中多次使用open打开同一个文件
		(2) 不同进程中去分别使用open打开同一个文件(不同进程间fd没有相关性)
		(3) linux系统提供了dup和dup2两个API来让进程复制文件描述符

        // 分析文件共享时的核心关注点在于: 分别写/读 还是 接续写/读

    3.1.10.3、再论文件描述符
        (1) 文件描述符本质是 进程表 中 文件描述符表(数组) 的index
			通过index查找文件 描述符表成员(数组成员)，从而通过V-node对内存中文件进行操作

        (2) fd就是0、1、2对应的文件为stdin、stdout、stderr		// 如：键盘设备文件

        (8) printf函数其实就是默认输出到标准输出stdout(文件)上
		    fpirntf函数可以指定输出到哪个文件描述符中

		file_table_struct
		{
			file status flags;
			current file offset;
			V-node pointer;
		}

        // 不同进程间 -> 文件描述符fd不同 -> 文件管理表(file table)不同 -> 文件指针(current file offset)不同

3.1.11.文件描述符的复制1
    3.1.11.2、使用dup进行文件描述符复制
        (1) dup系统调用对fd进行复制，会返回一个新的文件描述符（譬如原来的fd是3，返回的就是4）
        (2) dup系统调用不能指定复制后得到的fd的数字，是由操作系统内部自动分配，标准fd分配的原则。
        (3) dup返回的fd和原来的oldfd都指向oldfd打开的那个动态文件
            操作这两个fd实际操作的都是oldfd打开的那个文件。实际上构成了文件共享 // -- 同一个file table class?
        (4) dup返回的fd和原来的oldfd同时向一个文件写入时，结果是分别写还是接续写？

    3.1.11.3、使用dup的缺陷分析
        (1) dup并不能指定分配的新的文件描述符的数字，dup2系统调用修复了这个缺陷，
            所以平时项目中实际使用时根据具体情况来决定用dup还是dup2.
    3.1.11.4、练习
        (1) fd0、1、2这三个fd被标准输入、输出、错误通道占用
        (2) 可以close(1)关闭标准输出, 关闭后printf输出到标准输出的内容就看不到了
        (3) 然后使用dup重新分配得到1这个fd, 这时候就把oldfd打开的这个文件和我们1这个标准输出通道给绑定起来了
            这就叫标准输出的重定位
        (4) close和dup配合进行文件的重定位

	//fd = open("./test.txt", O_RDWR, ENABLE_RW);
	//fd1 = open("./test.txt", O_RDWR, ENABLE_RW);		// 两个文件分别写入，无接续效果，后面写入覆盖前面写入 -- O_APPEND
	//fd1 = dup(fd);		// 有接续写入效果

3.1.12.1、使用dup2进行文件描述符复制

3.1.12.3、命令行中重定位命令 >
	(1)linux中的shell命令执行后，打印结果都是默认进入stdout的（本质上是因为这些命令譬如ls、pwd等都是调用printf进行打印的）
		所以我们可以在linux的终端shell中直接看到命令执行的结果。
	(2)能否想办法把ls、pwd等命令的输出给重定位到一个文件中（譬如2.txt）去，
		实际上linux终端支持一个重定位的符号>很简单可以做到这点。
	(3)这个>的实现原理，其实就是利用open+close+dup，open打开一个文件2.txt，然后close关闭stdout，
		然后dup将1和2.txt文件关联起来即可。

3.1.13.fcntl函数介绍
3.1.13.1、fcntl的原型和作用
	(1)fcntl函数是一个多功能文件管理的工具箱，接收2个参数+1个变参。
		第一个参数是fd表示要操作哪个文件，
		第二个参数是cmd表示要进行哪个命令操作。
		变参是用来传递参数的，要配合cmd来使用。
	(2)cmd的样子类似于F_XXX，不同的cmd具有不同的功能。学习时没必要去把所有的cmd的含义都弄清楚（也记不住），
		只需要弄明白一个作为案例，搞清楚它怎么看怎么用就行了，其他的是类似的。
		其他的当我们在使用中碰到了一个fcntl的不认识的cmd时再去查man手册即可。

3.1.13.2、fcntl的常用cmd
	(1)F_DUPFD这个cmd的作用是复制文件描述符（作用类似于dup和dup2），
		这个命令的功能是从可用的fd数字列表中找一个比arg大或者和arg一样大的数字作为oldfd的一个复制的fd，
		和dup2有点像但是不同。dup2返回的就是我们指定的那个newfd否则就会出错，但是F_DUPFD命令返回的是>=arg的最小的那一个数字。

3.1.13.3、使用fcntl模拟dup2

3.1.14.标准IO库介绍
3.1.14.1、标准IO和文件IO有什么区别
	(1) 看起来使用时都是函数，但是：标准IO是C库函数，而文件IO是linux系统的API
	(2) C语言库函数是由API封装而来的。库函数内部也是通过调用API来完成操作的，但是库函数因为多了一层封装，所以比API要更加好用一些。
	(3) 库函数比API还有一个优势就是：API在不同的操作系统之间是不能通用的，但是C库函数在不同操作系统中几乎是一样的。
		所以C库函数具有可移植性而API不具有可移植性。
	(4) 性能上和易用性上看，C库函数一般要好一些。譬如IO，文件IO是不带缓存的，而标准IO是带缓存的，因此标准IO比文件IO性能要更高。

3.1.14.2、常用标准IO函数介绍
	(1) 常见的标准IO库函数有：fopen、fclose、fwrite、fread、ffulsh、fseek

3.1.14.3、一个简单的标准IO读写文件实例


nat方式：192.168.30.129
桥接方式：192.168.0.103

ln -s 软连接文件   l开头
ln 硬链接文件      -开头

apt-get install vim
apt-get remove vim

shell returned 127

man 1 linux shell命令
man 2 API
man 3 库函数

